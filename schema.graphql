"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type DFAvailableClaim {
  amount: BigDecimal!

  """id = {userId}-{tokenId}"""
  id: ID!
  receiver: DFReward!
  token: Token!
}

input DFAvailableClaim_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  receiver: String
  receiver_: DFReward_filter
  receiver_contains: String
  receiver_contains_nocase: String
  receiver_ends_with: String
  receiver_ends_with_nocase: String
  receiver_gt: String
  receiver_gte: String
  receiver_in: [String!]
  receiver_lt: String
  receiver_lte: String
  receiver_not: String
  receiver_not_contains: String
  receiver_not_contains_nocase: String
  receiver_not_ends_with: String
  receiver_not_ends_with_nocase: String
  receiver_not_in: [String!]
  receiver_not_starts_with: String
  receiver_not_starts_with_nocase: String
  receiver_starts_with: String
  receiver_starts_with_nocase: String
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
}

enum DFAvailableClaim_orderBy {
  amount
  id
  receiver
  token
}

type DFHistory {
  amount: BigDecimal!
  block: Int!
  eventIndex: Int!

  """id = {user-id}-{txId}-{eventId}"""
  id: ID!
  receiver: DFReward!
  timestamp: BigInt!
  token: Token!
  tx: String!
  type: DFHistoryType!
}

enum DFHistoryType {
  Allocated
  Claimed
}

input DFHistory_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  receiver: String
  receiver_: DFReward_filter
  receiver_contains: String
  receiver_contains_nocase: String
  receiver_ends_with: String
  receiver_ends_with_nocase: String
  receiver_gt: String
  receiver_gte: String
  receiver_in: [String!]
  receiver_lt: String
  receiver_lte: String
  receiver_not: String
  receiver_not_contains: String
  receiver_not_contains_nocase: String
  receiver_not_ends_with: String
  receiver_not_ends_with_nocase: String
  receiver_not_in: [String!]
  receiver_not_starts_with: String
  receiver_not_starts_with_nocase: String
  receiver_starts_with: String
  receiver_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  tx: String
  tx_contains: String
  tx_contains_nocase: String
  tx_ends_with: String
  tx_ends_with_nocase: String
  tx_gt: String
  tx_gte: String
  tx_in: [String!]
  tx_lt: String
  tx_lte: String
  tx_not: String
  tx_not_contains: String
  tx_not_contains_nocase: String
  tx_not_ends_with: String
  tx_not_ends_with_nocase: String
  tx_not_in: [String!]
  tx_not_starts_with: String
  tx_not_starts_with_nocase: String
  tx_starts_with: String
  tx_starts_with_nocase: String
  type: DFHistoryType
  type_in: [DFHistoryType!]
  type_not: DFHistoryType
  type_not_in: [DFHistoryType!]
}

enum DFHistory_orderBy {
  amount
  block
  eventIndex
  id
  receiver
  timestamp
  token
  tx
  type
}

type DFReward {
  availableClaims(first: Int = 100, orderBy: DFAvailableClaim_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: DFAvailableClaim_filter): [DFAvailableClaim!]
  history(first: Int = 100, orderBy: DFHistory_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: DFHistory_filter): [DFHistory!]

  """id = {user address}"""
  id: ID!
  receiver: User!
}

input DFReward_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  availableClaims_: DFAvailableClaim_filter
  history_: DFHistory_filter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  receiver: String
  receiver_: User_filter
  receiver_contains: String
  receiver_contains_nocase: String
  receiver_ends_with: String
  receiver_ends_with_nocase: String
  receiver_gt: String
  receiver_gte: String
  receiver_in: [String!]
  receiver_lt: String
  receiver_lte: String
  receiver_not: String
  receiver_not_contains: String
  receiver_not_contains_nocase: String
  receiver_not_ends_with: String
  receiver_not_ends_with_nocase: String
  receiver_not_in: [String!]
  receiver_not_starts_with: String
  receiver_not_starts_with_nocase: String
  receiver_starts_with: String
  receiver_starts_with_nocase: String
}

enum DFReward_orderBy {
  availableClaims
  history
  id
  receiver
}

type Dispenser {
  active: Boolean!
  allowedSwapper: String

  """how many tokens are left"""
  balance: BigDecimal!
  block: Int!
  contract: String!
  createdTimestamp: Int!
  dispenses(first: Int = 100, orderBy: DispenserTransaction_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: DispenserTransaction_filter): [DispenserTransaction!]
  eventIndex: Int!

  """token address"""
  id: ID!
  isMinter: Boolean

  """
  max balance of requester. If the balance is higher, the dispense is rejected
  """
  maxBalance: BigDecimal!

  """max tokens that can be dispensed"""
  maxTokens: BigDecimal!

  """
  if using the enterprise template the owner will always be the erc721 factory, for normal template it will a user
  """
  owner: String
  token: Token!
  tx: String!
}

type DispenserTransaction {
  amount: BigDecimal!
  block: Int!
  createdTimestamp: Int!
  dispenser: Dispenser!
  eventIndex: Int!
  id: ID!
  tx: String!
  user: User!
}

input DispenserTransaction_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  createdTimestamp: Int
  createdTimestamp_gt: Int
  createdTimestamp_gte: Int
  createdTimestamp_in: [Int!]
  createdTimestamp_lt: Int
  createdTimestamp_lte: Int
  createdTimestamp_not: Int
  createdTimestamp_not_in: [Int!]
  dispenser: String
  dispenser_: Dispenser_filter
  dispenser_contains: String
  dispenser_contains_nocase: String
  dispenser_ends_with: String
  dispenser_ends_with_nocase: String
  dispenser_gt: String
  dispenser_gte: String
  dispenser_in: [String!]
  dispenser_lt: String
  dispenser_lte: String
  dispenser_not: String
  dispenser_not_contains: String
  dispenser_not_contains_nocase: String
  dispenser_not_ends_with: String
  dispenser_not_ends_with_nocase: String
  dispenser_not_in: [String!]
  dispenser_not_starts_with: String
  dispenser_not_starts_with_nocase: String
  dispenser_starts_with: String
  dispenser_starts_with_nocase: String
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  tx: String
  tx_contains: String
  tx_contains_nocase: String
  tx_ends_with: String
  tx_ends_with_nocase: String
  tx_gt: String
  tx_gte: String
  tx_in: [String!]
  tx_lt: String
  tx_lte: String
  tx_not: String
  tx_not_contains: String
  tx_not_contains_nocase: String
  tx_not_ends_with: String
  tx_not_ends_with_nocase: String
  tx_not_in: [String!]
  tx_not_starts_with: String
  tx_not_starts_with_nocase: String
  tx_starts_with: String
  tx_starts_with_nocase: String
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum DispenserTransaction_orderBy {
  amount
  block
  createdTimestamp
  dispenser
  eventIndex
  id
  tx
  user
}

input Dispenser_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  active: Boolean
  active_in: [Boolean!]
  active_not: Boolean
  active_not_in: [Boolean!]
  allowedSwapper: String
  allowedSwapper_contains: String
  allowedSwapper_contains_nocase: String
  allowedSwapper_ends_with: String
  allowedSwapper_ends_with_nocase: String
  allowedSwapper_gt: String
  allowedSwapper_gte: String
  allowedSwapper_in: [String!]
  allowedSwapper_lt: String
  allowedSwapper_lte: String
  allowedSwapper_not: String
  allowedSwapper_not_contains: String
  allowedSwapper_not_contains_nocase: String
  allowedSwapper_not_ends_with: String
  allowedSwapper_not_ends_with_nocase: String
  allowedSwapper_not_in: [String!]
  allowedSwapper_not_starts_with: String
  allowedSwapper_not_starts_with_nocase: String
  allowedSwapper_starts_with: String
  allowedSwapper_starts_with_nocase: String
  balance: BigDecimal
  balance_gt: BigDecimal
  balance_gte: BigDecimal
  balance_in: [BigDecimal!]
  balance_lt: BigDecimal
  balance_lte: BigDecimal
  balance_not: BigDecimal
  balance_not_in: [BigDecimal!]
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  contract: String
  contract_contains: String
  contract_contains_nocase: String
  contract_ends_with: String
  contract_ends_with_nocase: String
  contract_gt: String
  contract_gte: String
  contract_in: [String!]
  contract_lt: String
  contract_lte: String
  contract_not: String
  contract_not_contains: String
  contract_not_contains_nocase: String
  contract_not_ends_with: String
  contract_not_ends_with_nocase: String
  contract_not_in: [String!]
  contract_not_starts_with: String
  contract_not_starts_with_nocase: String
  contract_starts_with: String
  contract_starts_with_nocase: String
  createdTimestamp: Int
  createdTimestamp_gt: Int
  createdTimestamp_gte: Int
  createdTimestamp_in: [Int!]
  createdTimestamp_lt: Int
  createdTimestamp_lte: Int
  createdTimestamp_not: Int
  createdTimestamp_not_in: [Int!]
  dispenses_: DispenserTransaction_filter
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isMinter: Boolean
  isMinter_in: [Boolean!]
  isMinter_not: Boolean
  isMinter_not_in: [Boolean!]
  maxBalance: BigDecimal
  maxBalance_gt: BigDecimal
  maxBalance_gte: BigDecimal
  maxBalance_in: [BigDecimal!]
  maxBalance_lt: BigDecimal
  maxBalance_lte: BigDecimal
  maxBalance_not: BigDecimal
  maxBalance_not_in: [BigDecimal!]
  maxTokens: BigDecimal
  maxTokens_gt: BigDecimal
  maxTokens_gte: BigDecimal
  maxTokens_in: [BigDecimal!]
  maxTokens_lt: BigDecimal
  maxTokens_lte: BigDecimal
  maxTokens_not: BigDecimal
  maxTokens_not_in: [BigDecimal!]
  owner: String
  owner_contains: String
  owner_contains_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_gt: String
  owner_gte: String
  owner_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_not: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_not_in: [String!]
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  tx: String
  tx_contains: String
  tx_contains_nocase: String
  tx_ends_with: String
  tx_ends_with_nocase: String
  tx_gt: String
  tx_gte: String
  tx_in: [String!]
  tx_lt: String
  tx_lte: String
  tx_not: String
  tx_not_contains: String
  tx_not_contains_nocase: String
  tx_not_ends_with: String
  tx_not_ends_with_nocase: String
  tx_not_in: [String!]
  tx_not_starts_with: String
  tx_not_starts_with_nocase: String
  tx_starts_with: String
  tx_starts_with_nocase: String
}

enum Dispenser_orderBy {
  active
  allowedSwapper
  balance
  block
  contract
  createdTimestamp
  dispenses
  eventIndex
  id
  isMinter
  maxBalance
  maxTokens
  owner
  token
  tx
}

type FixedRateExchange {
  active: Boolean!

  """address that is allowed to  swap tokens"""
  allowedSwapper: String
  baseToken: Token!
  baseTokenBalance: BigDecimal!

  """amount of basetokens available to be collected by the owner"""
  baseTokenSupply: BigDecimal!
  block: Int!
  contract: String!
  createdTimestamp: Int!
  datatoken: Token!
  datatokenBalance: BigDecimal!

  """
  amount of datatokens available to be sold, this is relevant if the exchange is not able to mint
  """
  datatokenSupply: BigDecimal!
  eventIndex: Int!
  exchangeId: String!

  """fixed rate exchange id"""
  id: ID!

  """if the fre has the minter role on the datatoken"""
  isMinter: Boolean
  owner: User!
  price: BigDecimal!

  """
  address of the market where the datatoken was created. This address collects market fees.
  """
  publishMarketFeeAddress: String

  """fee amount. Fixed value"""
  publishMarketSwapFee: BigDecimal
  swaps(first: Int = 100, orderBy: FixedRateExchangeSwap_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: FixedRateExchangeSwap_filter): [FixedRateExchangeSwap!]

  """amount of total basetokens spent"""
  totalSwapValue: BigDecimal!
  tx: String!
  updates(first: Int = 100, orderBy: FixedRateExchangeUpdate_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: FixedRateExchangeUpdate_filter): [FixedRateExchangeUpdate!]

  """if the owner allowes the fre to mint"""
  withMint: Boolean
}

type FixedRateExchangeSwap {
  baseTokenAmount: BigDecimal!
  block: Int!
  by: User!
  consumeMarketFeeAmount: BigDecimal!
  createdTimestamp: Int!
  dataTokenAmount: BigDecimal!
  eventIndex: Int!
  exchangeId: FixedRateExchange!
  id: ID!
  marketFeeAmount: BigDecimal!
  oceanFeeAmount: BigDecimal!
  tx: String!
}

input FixedRateExchangeSwap_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  baseTokenAmount: BigDecimal
  baseTokenAmount_gt: BigDecimal
  baseTokenAmount_gte: BigDecimal
  baseTokenAmount_in: [BigDecimal!]
  baseTokenAmount_lt: BigDecimal
  baseTokenAmount_lte: BigDecimal
  baseTokenAmount_not: BigDecimal
  baseTokenAmount_not_in: [BigDecimal!]
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  by: String
  by_: User_filter
  by_contains: String
  by_contains_nocase: String
  by_ends_with: String
  by_ends_with_nocase: String
  by_gt: String
  by_gte: String
  by_in: [String!]
  by_lt: String
  by_lte: String
  by_not: String
  by_not_contains: String
  by_not_contains_nocase: String
  by_not_ends_with: String
  by_not_ends_with_nocase: String
  by_not_in: [String!]
  by_not_starts_with: String
  by_not_starts_with_nocase: String
  by_starts_with: String
  by_starts_with_nocase: String
  consumeMarketFeeAmount: BigDecimal
  consumeMarketFeeAmount_gt: BigDecimal
  consumeMarketFeeAmount_gte: BigDecimal
  consumeMarketFeeAmount_in: [BigDecimal!]
  consumeMarketFeeAmount_lt: BigDecimal
  consumeMarketFeeAmount_lte: BigDecimal
  consumeMarketFeeAmount_not: BigDecimal
  consumeMarketFeeAmount_not_in: [BigDecimal!]
  createdTimestamp: Int
  createdTimestamp_gt: Int
  createdTimestamp_gte: Int
  createdTimestamp_in: [Int!]
  createdTimestamp_lt: Int
  createdTimestamp_lte: Int
  createdTimestamp_not: Int
  createdTimestamp_not_in: [Int!]
  dataTokenAmount: BigDecimal
  dataTokenAmount_gt: BigDecimal
  dataTokenAmount_gte: BigDecimal
  dataTokenAmount_in: [BigDecimal!]
  dataTokenAmount_lt: BigDecimal
  dataTokenAmount_lte: BigDecimal
  dataTokenAmount_not: BigDecimal
  dataTokenAmount_not_in: [BigDecimal!]
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  exchangeId: String
  exchangeId_: FixedRateExchange_filter
  exchangeId_contains: String
  exchangeId_contains_nocase: String
  exchangeId_ends_with: String
  exchangeId_ends_with_nocase: String
  exchangeId_gt: String
  exchangeId_gte: String
  exchangeId_in: [String!]
  exchangeId_lt: String
  exchangeId_lte: String
  exchangeId_not: String
  exchangeId_not_contains: String
  exchangeId_not_contains_nocase: String
  exchangeId_not_ends_with: String
  exchangeId_not_ends_with_nocase: String
  exchangeId_not_in: [String!]
  exchangeId_not_starts_with: String
  exchangeId_not_starts_with_nocase: String
  exchangeId_starts_with: String
  exchangeId_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  marketFeeAmount: BigDecimal
  marketFeeAmount_gt: BigDecimal
  marketFeeAmount_gte: BigDecimal
  marketFeeAmount_in: [BigDecimal!]
  marketFeeAmount_lt: BigDecimal
  marketFeeAmount_lte: BigDecimal
  marketFeeAmount_not: BigDecimal
  marketFeeAmount_not_in: [BigDecimal!]
  oceanFeeAmount: BigDecimal
  oceanFeeAmount_gt: BigDecimal
  oceanFeeAmount_gte: BigDecimal
  oceanFeeAmount_in: [BigDecimal!]
  oceanFeeAmount_lt: BigDecimal
  oceanFeeAmount_lte: BigDecimal
  oceanFeeAmount_not: BigDecimal
  oceanFeeAmount_not_in: [BigDecimal!]
  tx: String
  tx_contains: String
  tx_contains_nocase: String
  tx_ends_with: String
  tx_ends_with_nocase: String
  tx_gt: String
  tx_gte: String
  tx_in: [String!]
  tx_lt: String
  tx_lte: String
  tx_not: String
  tx_not_contains: String
  tx_not_contains_nocase: String
  tx_not_ends_with: String
  tx_not_ends_with_nocase: String
  tx_not_in: [String!]
  tx_not_starts_with: String
  tx_not_starts_with_nocase: String
  tx_starts_with: String
  tx_starts_with_nocase: String
}

enum FixedRateExchangeSwap_orderBy {
  baseTokenAmount
  block
  by
  consumeMarketFeeAmount
  createdTimestamp
  dataTokenAmount
  eventIndex
  exchangeId
  id
  marketFeeAmount
  oceanFeeAmount
  tx
}

type FixedRateExchangeUpdate {
  block: Int!
  createdTimestamp: Int!
  eventIndex: Int!
  exchangeId: FixedRateExchange!
  id: ID!
  newActive: Boolean
  newAllowedSwapper: String
  newPrice: BigDecimal
  oldActive: Boolean
  oldAllowedSwapper: String
  oldPrice: BigDecimal
  tx: String!
}

input FixedRateExchangeUpdate_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  createdTimestamp: Int
  createdTimestamp_gt: Int
  createdTimestamp_gte: Int
  createdTimestamp_in: [Int!]
  createdTimestamp_lt: Int
  createdTimestamp_lte: Int
  createdTimestamp_not: Int
  createdTimestamp_not_in: [Int!]
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  exchangeId: String
  exchangeId_: FixedRateExchange_filter
  exchangeId_contains: String
  exchangeId_contains_nocase: String
  exchangeId_ends_with: String
  exchangeId_ends_with_nocase: String
  exchangeId_gt: String
  exchangeId_gte: String
  exchangeId_in: [String!]
  exchangeId_lt: String
  exchangeId_lte: String
  exchangeId_not: String
  exchangeId_not_contains: String
  exchangeId_not_contains_nocase: String
  exchangeId_not_ends_with: String
  exchangeId_not_ends_with_nocase: String
  exchangeId_not_in: [String!]
  exchangeId_not_starts_with: String
  exchangeId_not_starts_with_nocase: String
  exchangeId_starts_with: String
  exchangeId_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  newActive: Boolean
  newActive_in: [Boolean!]
  newActive_not: Boolean
  newActive_not_in: [Boolean!]
  newAllowedSwapper: String
  newAllowedSwapper_contains: String
  newAllowedSwapper_contains_nocase: String
  newAllowedSwapper_ends_with: String
  newAllowedSwapper_ends_with_nocase: String
  newAllowedSwapper_gt: String
  newAllowedSwapper_gte: String
  newAllowedSwapper_in: [String!]
  newAllowedSwapper_lt: String
  newAllowedSwapper_lte: String
  newAllowedSwapper_not: String
  newAllowedSwapper_not_contains: String
  newAllowedSwapper_not_contains_nocase: String
  newAllowedSwapper_not_ends_with: String
  newAllowedSwapper_not_ends_with_nocase: String
  newAllowedSwapper_not_in: [String!]
  newAllowedSwapper_not_starts_with: String
  newAllowedSwapper_not_starts_with_nocase: String
  newAllowedSwapper_starts_with: String
  newAllowedSwapper_starts_with_nocase: String
  newPrice: BigDecimal
  newPrice_gt: BigDecimal
  newPrice_gte: BigDecimal
  newPrice_in: [BigDecimal!]
  newPrice_lt: BigDecimal
  newPrice_lte: BigDecimal
  newPrice_not: BigDecimal
  newPrice_not_in: [BigDecimal!]
  oldActive: Boolean
  oldActive_in: [Boolean!]
  oldActive_not: Boolean
  oldActive_not_in: [Boolean!]
  oldAllowedSwapper: String
  oldAllowedSwapper_contains: String
  oldAllowedSwapper_contains_nocase: String
  oldAllowedSwapper_ends_with: String
  oldAllowedSwapper_ends_with_nocase: String
  oldAllowedSwapper_gt: String
  oldAllowedSwapper_gte: String
  oldAllowedSwapper_in: [String!]
  oldAllowedSwapper_lt: String
  oldAllowedSwapper_lte: String
  oldAllowedSwapper_not: String
  oldAllowedSwapper_not_contains: String
  oldAllowedSwapper_not_contains_nocase: String
  oldAllowedSwapper_not_ends_with: String
  oldAllowedSwapper_not_ends_with_nocase: String
  oldAllowedSwapper_not_in: [String!]
  oldAllowedSwapper_not_starts_with: String
  oldAllowedSwapper_not_starts_with_nocase: String
  oldAllowedSwapper_starts_with: String
  oldAllowedSwapper_starts_with_nocase: String
  oldPrice: BigDecimal
  oldPrice_gt: BigDecimal
  oldPrice_gte: BigDecimal
  oldPrice_in: [BigDecimal!]
  oldPrice_lt: BigDecimal
  oldPrice_lte: BigDecimal
  oldPrice_not: BigDecimal
  oldPrice_not_in: [BigDecimal!]
  tx: String
  tx_contains: String
  tx_contains_nocase: String
  tx_ends_with: String
  tx_ends_with_nocase: String
  tx_gt: String
  tx_gte: String
  tx_in: [String!]
  tx_lt: String
  tx_lte: String
  tx_not: String
  tx_not_contains: String
  tx_not_contains_nocase: String
  tx_not_ends_with: String
  tx_not_ends_with_nocase: String
  tx_not_in: [String!]
  tx_not_starts_with: String
  tx_not_starts_with_nocase: String
  tx_starts_with: String
  tx_starts_with_nocase: String
}

enum FixedRateExchangeUpdate_orderBy {
  block
  createdTimestamp
  eventIndex
  exchangeId
  id
  newActive
  newAllowedSwapper
  newPrice
  oldActive
  oldAllowedSwapper
  oldPrice
  tx
}

input FixedRateExchange_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  active: Boolean
  active_in: [Boolean!]
  active_not: Boolean
  active_not_in: [Boolean!]
  allowedSwapper: String
  allowedSwapper_contains: String
  allowedSwapper_contains_nocase: String
  allowedSwapper_ends_with: String
  allowedSwapper_ends_with_nocase: String
  allowedSwapper_gt: String
  allowedSwapper_gte: String
  allowedSwapper_in: [String!]
  allowedSwapper_lt: String
  allowedSwapper_lte: String
  allowedSwapper_not: String
  allowedSwapper_not_contains: String
  allowedSwapper_not_contains_nocase: String
  allowedSwapper_not_ends_with: String
  allowedSwapper_not_ends_with_nocase: String
  allowedSwapper_not_in: [String!]
  allowedSwapper_not_starts_with: String
  allowedSwapper_not_starts_with_nocase: String
  allowedSwapper_starts_with: String
  allowedSwapper_starts_with_nocase: String
  baseToken: String
  baseTokenBalance: BigDecimal
  baseTokenBalance_gt: BigDecimal
  baseTokenBalance_gte: BigDecimal
  baseTokenBalance_in: [BigDecimal!]
  baseTokenBalance_lt: BigDecimal
  baseTokenBalance_lte: BigDecimal
  baseTokenBalance_not: BigDecimal
  baseTokenBalance_not_in: [BigDecimal!]
  baseTokenSupply: BigDecimal
  baseTokenSupply_gt: BigDecimal
  baseTokenSupply_gte: BigDecimal
  baseTokenSupply_in: [BigDecimal!]
  baseTokenSupply_lt: BigDecimal
  baseTokenSupply_lte: BigDecimal
  baseTokenSupply_not: BigDecimal
  baseTokenSupply_not_in: [BigDecimal!]
  baseToken_: Token_filter
  baseToken_contains: String
  baseToken_contains_nocase: String
  baseToken_ends_with: String
  baseToken_ends_with_nocase: String
  baseToken_gt: String
  baseToken_gte: String
  baseToken_in: [String!]
  baseToken_lt: String
  baseToken_lte: String
  baseToken_not: String
  baseToken_not_contains: String
  baseToken_not_contains_nocase: String
  baseToken_not_ends_with: String
  baseToken_not_ends_with_nocase: String
  baseToken_not_in: [String!]
  baseToken_not_starts_with: String
  baseToken_not_starts_with_nocase: String
  baseToken_starts_with: String
  baseToken_starts_with_nocase: String
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  contract: String
  contract_contains: String
  contract_contains_nocase: String
  contract_ends_with: String
  contract_ends_with_nocase: String
  contract_gt: String
  contract_gte: String
  contract_in: [String!]
  contract_lt: String
  contract_lte: String
  contract_not: String
  contract_not_contains: String
  contract_not_contains_nocase: String
  contract_not_ends_with: String
  contract_not_ends_with_nocase: String
  contract_not_in: [String!]
  contract_not_starts_with: String
  contract_not_starts_with_nocase: String
  contract_starts_with: String
  contract_starts_with_nocase: String
  createdTimestamp: Int
  createdTimestamp_gt: Int
  createdTimestamp_gte: Int
  createdTimestamp_in: [Int!]
  createdTimestamp_lt: Int
  createdTimestamp_lte: Int
  createdTimestamp_not: Int
  createdTimestamp_not_in: [Int!]
  datatoken: String
  datatokenBalance: BigDecimal
  datatokenBalance_gt: BigDecimal
  datatokenBalance_gte: BigDecimal
  datatokenBalance_in: [BigDecimal!]
  datatokenBalance_lt: BigDecimal
  datatokenBalance_lte: BigDecimal
  datatokenBalance_not: BigDecimal
  datatokenBalance_not_in: [BigDecimal!]
  datatokenSupply: BigDecimal
  datatokenSupply_gt: BigDecimal
  datatokenSupply_gte: BigDecimal
  datatokenSupply_in: [BigDecimal!]
  datatokenSupply_lt: BigDecimal
  datatokenSupply_lte: BigDecimal
  datatokenSupply_not: BigDecimal
  datatokenSupply_not_in: [BigDecimal!]
  datatoken_: Token_filter
  datatoken_contains: String
  datatoken_contains_nocase: String
  datatoken_ends_with: String
  datatoken_ends_with_nocase: String
  datatoken_gt: String
  datatoken_gte: String
  datatoken_in: [String!]
  datatoken_lt: String
  datatoken_lte: String
  datatoken_not: String
  datatoken_not_contains: String
  datatoken_not_contains_nocase: String
  datatoken_not_ends_with: String
  datatoken_not_ends_with_nocase: String
  datatoken_not_in: [String!]
  datatoken_not_starts_with: String
  datatoken_not_starts_with_nocase: String
  datatoken_starts_with: String
  datatoken_starts_with_nocase: String
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  exchangeId: String
  exchangeId_contains: String
  exchangeId_contains_nocase: String
  exchangeId_ends_with: String
  exchangeId_ends_with_nocase: String
  exchangeId_gt: String
  exchangeId_gte: String
  exchangeId_in: [String!]
  exchangeId_lt: String
  exchangeId_lte: String
  exchangeId_not: String
  exchangeId_not_contains: String
  exchangeId_not_contains_nocase: String
  exchangeId_not_ends_with: String
  exchangeId_not_ends_with_nocase: String
  exchangeId_not_in: [String!]
  exchangeId_not_starts_with: String
  exchangeId_not_starts_with_nocase: String
  exchangeId_starts_with: String
  exchangeId_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isMinter: Boolean
  isMinter_in: [Boolean!]
  isMinter_not: Boolean
  isMinter_not_in: [Boolean!]
  owner: String
  owner_: User_filter
  owner_contains: String
  owner_contains_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_gt: String
  owner_gte: String
  owner_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_not: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_not_in: [String!]
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  price: BigDecimal
  price_gt: BigDecimal
  price_gte: BigDecimal
  price_in: [BigDecimal!]
  price_lt: BigDecimal
  price_lte: BigDecimal
  price_not: BigDecimal
  price_not_in: [BigDecimal!]
  publishMarketFeeAddress: String
  publishMarketFeeAddress_contains: String
  publishMarketFeeAddress_contains_nocase: String
  publishMarketFeeAddress_ends_with: String
  publishMarketFeeAddress_ends_with_nocase: String
  publishMarketFeeAddress_gt: String
  publishMarketFeeAddress_gte: String
  publishMarketFeeAddress_in: [String!]
  publishMarketFeeAddress_lt: String
  publishMarketFeeAddress_lte: String
  publishMarketFeeAddress_not: String
  publishMarketFeeAddress_not_contains: String
  publishMarketFeeAddress_not_contains_nocase: String
  publishMarketFeeAddress_not_ends_with: String
  publishMarketFeeAddress_not_ends_with_nocase: String
  publishMarketFeeAddress_not_in: [String!]
  publishMarketFeeAddress_not_starts_with: String
  publishMarketFeeAddress_not_starts_with_nocase: String
  publishMarketFeeAddress_starts_with: String
  publishMarketFeeAddress_starts_with_nocase: String
  publishMarketSwapFee: BigDecimal
  publishMarketSwapFee_gt: BigDecimal
  publishMarketSwapFee_gte: BigDecimal
  publishMarketSwapFee_in: [BigDecimal!]
  publishMarketSwapFee_lt: BigDecimal
  publishMarketSwapFee_lte: BigDecimal
  publishMarketSwapFee_not: BigDecimal
  publishMarketSwapFee_not_in: [BigDecimal!]
  swaps_: FixedRateExchangeSwap_filter
  totalSwapValue: BigDecimal
  totalSwapValue_gt: BigDecimal
  totalSwapValue_gte: BigDecimal
  totalSwapValue_in: [BigDecimal!]
  totalSwapValue_lt: BigDecimal
  totalSwapValue_lte: BigDecimal
  totalSwapValue_not: BigDecimal
  totalSwapValue_not_in: [BigDecimal!]
  tx: String
  tx_contains: String
  tx_contains_nocase: String
  tx_ends_with: String
  tx_ends_with_nocase: String
  tx_gt: String
  tx_gte: String
  tx_in: [String!]
  tx_lt: String
  tx_lte: String
  tx_not: String
  tx_not_contains: String
  tx_not_contains_nocase: String
  tx_not_ends_with: String
  tx_not_ends_with_nocase: String
  tx_not_in: [String!]
  tx_not_starts_with: String
  tx_not_starts_with_nocase: String
  tx_starts_with: String
  tx_starts_with_nocase: String
  updates_: FixedRateExchangeUpdate_filter
  withMint: Boolean
  withMint_in: [Boolean!]
  withMint_not: Boolean
  withMint_not_in: [Boolean!]
}

enum FixedRateExchange_orderBy {
  active
  allowedSwapper
  baseToken
  baseTokenBalance
  baseTokenSupply
  block
  contract
  createdTimestamp
  datatoken
  datatokenBalance
  datatokenSupply
  eventIndex
  exchangeId
  id
  isMinter
  owner
  price
  publishMarketFeeAddress
  publishMarketSwapFee
  swaps
  totalSwapValue
  tx
  updates
  withMint
}

type GlobalStatistic {
  """total datatokens (tokens with isDatatoken = true) created"""
  datatokenCount: Int!

  """number of dispensers created"""
  dispenserCount: Int!

  """number of fixed rate exchanges"""
  fixedCount: Int!
  id: ID!

  """total nfts(erc721) created"""
  nftCount: Int!

  """number of total orders. fixed rate exchange orders + dispenser orders"""
  orderCount: Int!

  """total swap volume for each base token in fixed rate exchanges"""
  totalFixedSwapVolume(first: Int = 100, orderBy: GlobalTotalFixedSwapPair_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: GlobalTotalFixedSwapPair_filter): [GlobalTotalFixedSwapPair!]

  """total ocean locked in veOcean"""
  totalOceanLocked: BigDecimal!

  """current version"""
  version: String
}

input GlobalStatistic_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  datatokenCount: Int
  datatokenCount_gt: Int
  datatokenCount_gte: Int
  datatokenCount_in: [Int!]
  datatokenCount_lt: Int
  datatokenCount_lte: Int
  datatokenCount_not: Int
  datatokenCount_not_in: [Int!]
  dispenserCount: Int
  dispenserCount_gt: Int
  dispenserCount_gte: Int
  dispenserCount_in: [Int!]
  dispenserCount_lt: Int
  dispenserCount_lte: Int
  dispenserCount_not: Int
  dispenserCount_not_in: [Int!]
  fixedCount: Int
  fixedCount_gt: Int
  fixedCount_gte: Int
  fixedCount_in: [Int!]
  fixedCount_lt: Int
  fixedCount_lte: Int
  fixedCount_not: Int
  fixedCount_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  nftCount: Int
  nftCount_gt: Int
  nftCount_gte: Int
  nftCount_in: [Int!]
  nftCount_lt: Int
  nftCount_lte: Int
  nftCount_not: Int
  nftCount_not_in: [Int!]
  orderCount: Int
  orderCount_gt: Int
  orderCount_gte: Int
  orderCount_in: [Int!]
  orderCount_lt: Int
  orderCount_lte: Int
  orderCount_not: Int
  orderCount_not_in: [Int!]
  totalFixedSwapVolume_: GlobalTotalFixedSwapPair_filter
  totalOceanLocked: BigDecimal
  totalOceanLocked_gt: BigDecimal
  totalOceanLocked_gte: BigDecimal
  totalOceanLocked_in: [BigDecimal!]
  totalOceanLocked_lt: BigDecimal
  totalOceanLocked_lte: BigDecimal
  totalOceanLocked_not: BigDecimal
  totalOceanLocked_not_in: [BigDecimal!]
  version: String
  version_contains: String
  version_contains_nocase: String
  version_ends_with: String
  version_ends_with_nocase: String
  version_gt: String
  version_gte: String
  version_in: [String!]
  version_lt: String
  version_lte: String
  version_not: String
  version_not_contains: String
  version_not_contains_nocase: String
  version_not_ends_with: String
  version_not_ends_with_nocase: String
  version_not_in: [String!]
  version_not_starts_with: String
  version_not_starts_with_nocase: String
  version_starts_with: String
  version_starts_with_nocase: String
}

enum GlobalStatistic_orderBy {
  datatokenCount
  dispenserCount
  fixedCount
  id
  nftCount
  orderCount
  totalFixedSwapVolume
  totalOceanLocked
  version
}

"""utility type"""
type GlobalTotalFixedSwapPair {
  count: BigInt!
  globalStatistic: GlobalStatistic!

  """address of the token"""
  id: ID!
  token: Token!
  value: BigDecimal!
}

input GlobalTotalFixedSwapPair_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  count: BigInt
  count_gt: BigInt
  count_gte: BigInt
  count_in: [BigInt!]
  count_lt: BigInt
  count_lte: BigInt
  count_not: BigInt
  count_not_in: [BigInt!]
  globalStatistic: String
  globalStatistic_: GlobalStatistic_filter
  globalStatistic_contains: String
  globalStatistic_contains_nocase: String
  globalStatistic_ends_with: String
  globalStatistic_ends_with_nocase: String
  globalStatistic_gt: String
  globalStatistic_gte: String
  globalStatistic_in: [String!]
  globalStatistic_lt: String
  globalStatistic_lte: String
  globalStatistic_not: String
  globalStatistic_not_contains: String
  globalStatistic_not_contains_nocase: String
  globalStatistic_not_ends_with: String
  globalStatistic_not_ends_with_nocase: String
  globalStatistic_not_in: [String!]
  globalStatistic_not_starts_with: String
  globalStatistic_not_starts_with_nocase: String
  globalStatistic_starts_with: String
  globalStatistic_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  value: BigDecimal
  value_gt: BigDecimal
  value_gte: BigDecimal
  value_in: [BigDecimal!]
  value_lt: BigDecimal
  value_lte: BigDecimal
  value_not: BigDecimal
  value_not_in: [BigDecimal!]
}

enum GlobalTotalFixedSwapPair_orderBy {
  count
  globalStatistic
  id
  token
  value
}

"""utility type"""
type GlobalTotalLiquidityPair {
  globalStatistic: GlobalStatistic!

  """address of the token"""
  id: ID!
  token: Token!
  value: BigDecimal!
}

input GlobalTotalLiquidityPair_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  globalStatistic: String
  globalStatistic_: GlobalStatistic_filter
  globalStatistic_contains: String
  globalStatistic_contains_nocase: String
  globalStatistic_ends_with: String
  globalStatistic_ends_with_nocase: String
  globalStatistic_gt: String
  globalStatistic_gte: String
  globalStatistic_in: [String!]
  globalStatistic_lt: String
  globalStatistic_lte: String
  globalStatistic_not: String
  globalStatistic_not_contains: String
  globalStatistic_not_contains_nocase: String
  globalStatistic_not_ends_with: String
  globalStatistic_not_ends_with_nocase: String
  globalStatistic_not_in: [String!]
  globalStatistic_not_starts_with: String
  globalStatistic_not_starts_with_nocase: String
  globalStatistic_starts_with: String
  globalStatistic_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  value: BigDecimal
  value_gt: BigDecimal
  value_gte: BigDecimal
  value_in: [BigDecimal!]
  value_lt: BigDecimal
  value_lte: BigDecimal
  value_not: BigDecimal
  value_not_in: [BigDecimal!]
}

enum GlobalTotalLiquidityPair_orderBy {
  globalStatistic
  id
  token
  value
}

type Nft {
  """same as id, it's just for easy discoverability"""
  address: String!

  """state of the asset (described in docs)"""
  assetState: Int!

  """block number when it was created"""
  block: Int

  """block time nft was created"""
  createdTimestamp: Int!

  """address of the creator of the nft"""
  creator: User!
  erc20DeployerRole: [String!]
  eventIndex: Int!

  """has metadata"""
  hasMetadata: Boolean!

  """nft address"""
  id: ID!
  managerRole: [String!]

  """addresses that can update the metadata"""
  metadataRole: [String!]
  name: String!
  nftData(first: Int = 100, orderBy: NftData_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: NftData_filter): [NftData!]

  """number of orders executed for all underlying datatokens"""
  orderCount: BigInt!

  """address of the owner of the nft"""
  owner: User!

  """provider url that can decrypt the ddo"""
  providerUrl: String
  storeUpdateRole: [String!]
  symbol: String!

  """template address"""
  template: String!
  tokenUri: String
  transferHistory(first: Int = 100, orderBy: NftTransferHistory_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: NftTransferHistory_filter): [NftTransferHistory!]

  """set if NFT is transferable"""
  transferable: Boolean!

  """nft creation transaction id"""
  tx: String!
}

type NftData {
  """nft address+key"""
  id: ID!
  key: Bytes
  nft: Nft!
  value: Bytes
}

input NftData_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  key: Bytes
  key_contains: Bytes
  key_in: [Bytes!]
  key_not: Bytes
  key_not_contains: Bytes
  key_not_in: [Bytes!]
  nft: String
  nft_: Nft_filter
  nft_contains: String
  nft_contains_nocase: String
  nft_ends_with: String
  nft_ends_with_nocase: String
  nft_gt: String
  nft_gte: String
  nft_in: [String!]
  nft_lt: String
  nft_lte: String
  nft_not: String
  nft_not_contains: String
  nft_not_contains_nocase: String
  nft_not_ends_with: String
  nft_not_ends_with_nocase: String
  nft_not_in: [String!]
  nft_not_starts_with: String
  nft_not_starts_with_nocase: String
  nft_starts_with: String
  nft_starts_with_nocase: String
  value: Bytes
  value_contains: Bytes
  value_in: [Bytes!]
  value_not: Bytes
  value_not_contains: Bytes
  value_not_in: [Bytes!]
}

enum NftData_orderBy {
  id
  key
  nft
  value
}

type NftTransferHistory {
  block: Int!
  eventIndex: Int!
  id: ID!
  newOwner: User!
  nft: Nft!
  oldOwner: User!
  timestamp: Int!
  txId: String
}

input NftTransferHistory_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  newOwner: String
  newOwner_: User_filter
  newOwner_contains: String
  newOwner_contains_nocase: String
  newOwner_ends_with: String
  newOwner_ends_with_nocase: String
  newOwner_gt: String
  newOwner_gte: String
  newOwner_in: [String!]
  newOwner_lt: String
  newOwner_lte: String
  newOwner_not: String
  newOwner_not_contains: String
  newOwner_not_contains_nocase: String
  newOwner_not_ends_with: String
  newOwner_not_ends_with_nocase: String
  newOwner_not_in: [String!]
  newOwner_not_starts_with: String
  newOwner_not_starts_with_nocase: String
  newOwner_starts_with: String
  newOwner_starts_with_nocase: String
  nft: String
  nft_: Nft_filter
  nft_contains: String
  nft_contains_nocase: String
  nft_ends_with: String
  nft_ends_with_nocase: String
  nft_gt: String
  nft_gte: String
  nft_in: [String!]
  nft_lt: String
  nft_lte: String
  nft_not: String
  nft_not_contains: String
  nft_not_contains_nocase: String
  nft_not_ends_with: String
  nft_not_ends_with_nocase: String
  nft_not_in: [String!]
  nft_not_starts_with: String
  nft_not_starts_with_nocase: String
  nft_starts_with: String
  nft_starts_with_nocase: String
  oldOwner: String
  oldOwner_: User_filter
  oldOwner_contains: String
  oldOwner_contains_nocase: String
  oldOwner_ends_with: String
  oldOwner_ends_with_nocase: String
  oldOwner_gt: String
  oldOwner_gte: String
  oldOwner_in: [String!]
  oldOwner_lt: String
  oldOwner_lte: String
  oldOwner_not: String
  oldOwner_not_contains: String
  oldOwner_not_contains_nocase: String
  oldOwner_not_ends_with: String
  oldOwner_not_ends_with_nocase: String
  oldOwner_not_in: [String!]
  oldOwner_not_starts_with: String
  oldOwner_not_starts_with_nocase: String
  oldOwner_starts_with: String
  oldOwner_starts_with_nocase: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  txId: String
  txId_contains: String
  txId_contains_nocase: String
  txId_ends_with: String
  txId_ends_with_nocase: String
  txId_gt: String
  txId_gte: String
  txId_in: [String!]
  txId_lt: String
  txId_lte: String
  txId_not: String
  txId_not_contains: String
  txId_not_contains_nocase: String
  txId_not_ends_with: String
  txId_not_ends_with_nocase: String
  txId_not_in: [String!]
  txId_not_starts_with: String
  txId_not_starts_with_nocase: String
  txId_starts_with: String
  txId_starts_with_nocase: String
}

enum NftTransferHistory_orderBy {
  block
  eventIndex
  id
  newOwner
  nft
  oldOwner
  timestamp
  txId
}

type NftUpdate {
  """state of the asset in this update"""
  assetState: Int!
  block: Int!
  eventIndex: Int!
  id: ID!
  nft: Nft!

  """provider url that can decrypt the ddo"""
  providerUrl: String
  timestamp: Int!
  tokenUri: String
  tx: String!

  """
  type of the update: metadata created, metadata update, state update, token uri update
  """
  type: NftUpdateType!

  """user that made the update"""
  userAddress: String!
}

enum NftUpdateType {
  METADATA_CREATED
  METADATA_UPDATED
  STATE_UPDATED
  TOKENURI_UPDATED
}

input NftUpdate_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  assetState: Int
  assetState_gt: Int
  assetState_gte: Int
  assetState_in: [Int!]
  assetState_lt: Int
  assetState_lte: Int
  assetState_not: Int
  assetState_not_in: [Int!]
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  nft: String
  nft_: Nft_filter
  nft_contains: String
  nft_contains_nocase: String
  nft_ends_with: String
  nft_ends_with_nocase: String
  nft_gt: String
  nft_gte: String
  nft_in: [String!]
  nft_lt: String
  nft_lte: String
  nft_not: String
  nft_not_contains: String
  nft_not_contains_nocase: String
  nft_not_ends_with: String
  nft_not_ends_with_nocase: String
  nft_not_in: [String!]
  nft_not_starts_with: String
  nft_not_starts_with_nocase: String
  nft_starts_with: String
  nft_starts_with_nocase: String
  providerUrl: String
  providerUrl_contains: String
  providerUrl_contains_nocase: String
  providerUrl_ends_with: String
  providerUrl_ends_with_nocase: String
  providerUrl_gt: String
  providerUrl_gte: String
  providerUrl_in: [String!]
  providerUrl_lt: String
  providerUrl_lte: String
  providerUrl_not: String
  providerUrl_not_contains: String
  providerUrl_not_contains_nocase: String
  providerUrl_not_ends_with: String
  providerUrl_not_ends_with_nocase: String
  providerUrl_not_in: [String!]
  providerUrl_not_starts_with: String
  providerUrl_not_starts_with_nocase: String
  providerUrl_starts_with: String
  providerUrl_starts_with_nocase: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  tokenUri: String
  tokenUri_contains: String
  tokenUri_contains_nocase: String
  tokenUri_ends_with: String
  tokenUri_ends_with_nocase: String
  tokenUri_gt: String
  tokenUri_gte: String
  tokenUri_in: [String!]
  tokenUri_lt: String
  tokenUri_lte: String
  tokenUri_not: String
  tokenUri_not_contains: String
  tokenUri_not_contains_nocase: String
  tokenUri_not_ends_with: String
  tokenUri_not_ends_with_nocase: String
  tokenUri_not_in: [String!]
  tokenUri_not_starts_with: String
  tokenUri_not_starts_with_nocase: String
  tokenUri_starts_with: String
  tokenUri_starts_with_nocase: String
  tx: String
  tx_contains: String
  tx_contains_nocase: String
  tx_ends_with: String
  tx_ends_with_nocase: String
  tx_gt: String
  tx_gte: String
  tx_in: [String!]
  tx_lt: String
  tx_lte: String
  tx_not: String
  tx_not_contains: String
  tx_not_contains_nocase: String
  tx_not_ends_with: String
  tx_not_ends_with_nocase: String
  tx_not_in: [String!]
  tx_not_starts_with: String
  tx_not_starts_with_nocase: String
  tx_starts_with: String
  tx_starts_with_nocase: String
  type: NftUpdateType
  type_in: [NftUpdateType!]
  type_not: NftUpdateType
  type_not_in: [NftUpdateType!]
  userAddress: String
  userAddress_contains: String
  userAddress_contains_nocase: String
  userAddress_ends_with: String
  userAddress_ends_with_nocase: String
  userAddress_gt: String
  userAddress_gte: String
  userAddress_in: [String!]
  userAddress_lt: String
  userAddress_lte: String
  userAddress_not: String
  userAddress_not_contains: String
  userAddress_not_contains_nocase: String
  userAddress_not_ends_with: String
  userAddress_not_ends_with_nocase: String
  userAddress_not_in: [String!]
  userAddress_not_starts_with: String
  userAddress_not_starts_with_nocase: String
  userAddress_starts_with: String
  userAddress_starts_with_nocase: String
}

enum NftUpdate_orderBy {
  assetState
  block
  eventIndex
  id
  nft
  providerUrl
  timestamp
  tokenUri
  tx
  type
  userAddress
}

input Nft_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  address: String
  address_contains: String
  address_contains_nocase: String
  address_ends_with: String
  address_ends_with_nocase: String
  address_gt: String
  address_gte: String
  address_in: [String!]
  address_lt: String
  address_lte: String
  address_not: String
  address_not_contains: String
  address_not_contains_nocase: String
  address_not_ends_with: String
  address_not_ends_with_nocase: String
  address_not_in: [String!]
  address_not_starts_with: String
  address_not_starts_with_nocase: String
  address_starts_with: String
  address_starts_with_nocase: String
  assetState: Int
  assetState_gt: Int
  assetState_gte: Int
  assetState_in: [Int!]
  assetState_lt: Int
  assetState_lte: Int
  assetState_not: Int
  assetState_not_in: [Int!]
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  createdTimestamp: Int
  createdTimestamp_gt: Int
  createdTimestamp_gte: Int
  createdTimestamp_in: [Int!]
  createdTimestamp_lt: Int
  createdTimestamp_lte: Int
  createdTimestamp_not: Int
  createdTimestamp_not_in: [Int!]
  creator: String
  creator_: User_filter
  creator_contains: String
  creator_contains_nocase: String
  creator_ends_with: String
  creator_ends_with_nocase: String
  creator_gt: String
  creator_gte: String
  creator_in: [String!]
  creator_lt: String
  creator_lte: String
  creator_not: String
  creator_not_contains: String
  creator_not_contains_nocase: String
  creator_not_ends_with: String
  creator_not_ends_with_nocase: String
  creator_not_in: [String!]
  creator_not_starts_with: String
  creator_not_starts_with_nocase: String
  creator_starts_with: String
  creator_starts_with_nocase: String
  erc20DeployerRole: [String!]
  erc20DeployerRole_contains: [String!]
  erc20DeployerRole_contains_nocase: [String!]
  erc20DeployerRole_not: [String!]
  erc20DeployerRole_not_contains: [String!]
  erc20DeployerRole_not_contains_nocase: [String!]
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  hasMetadata: Boolean
  hasMetadata_in: [Boolean!]
  hasMetadata_not: Boolean
  hasMetadata_not_in: [Boolean!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  managerRole: [String!]
  managerRole_contains: [String!]
  managerRole_contains_nocase: [String!]
  managerRole_not: [String!]
  managerRole_not_contains: [String!]
  managerRole_not_contains_nocase: [String!]
  metadataRole: [String!]
  metadataRole_contains: [String!]
  metadataRole_contains_nocase: [String!]
  metadataRole_not: [String!]
  metadataRole_not_contains: [String!]
  metadataRole_not_contains_nocase: [String!]
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  nftData_: NftData_filter
  orderCount: BigInt
  orderCount_gt: BigInt
  orderCount_gte: BigInt
  orderCount_in: [BigInt!]
  orderCount_lt: BigInt
  orderCount_lte: BigInt
  orderCount_not: BigInt
  orderCount_not_in: [BigInt!]
  owner: String
  owner_: User_filter
  owner_contains: String
  owner_contains_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_gt: String
  owner_gte: String
  owner_in: [String!]
  owner_lt: String
  owner_lte: String
  owner_not: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_not_in: [String!]
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  providerUrl: String
  providerUrl_contains: String
  providerUrl_contains_nocase: String
  providerUrl_ends_with: String
  providerUrl_ends_with_nocase: String
  providerUrl_gt: String
  providerUrl_gte: String
  providerUrl_in: [String!]
  providerUrl_lt: String
  providerUrl_lte: String
  providerUrl_not: String
  providerUrl_not_contains: String
  providerUrl_not_contains_nocase: String
  providerUrl_not_ends_with: String
  providerUrl_not_ends_with_nocase: String
  providerUrl_not_in: [String!]
  providerUrl_not_starts_with: String
  providerUrl_not_starts_with_nocase: String
  providerUrl_starts_with: String
  providerUrl_starts_with_nocase: String
  storeUpdateRole: [String!]
  storeUpdateRole_contains: [String!]
  storeUpdateRole_contains_nocase: [String!]
  storeUpdateRole_not: [String!]
  storeUpdateRole_not_contains: [String!]
  storeUpdateRole_not_contains_nocase: [String!]
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  template: String
  template_contains: String
  template_contains_nocase: String
  template_ends_with: String
  template_ends_with_nocase: String
  template_gt: String
  template_gte: String
  template_in: [String!]
  template_lt: String
  template_lte: String
  template_not: String
  template_not_contains: String
  template_not_contains_nocase: String
  template_not_ends_with: String
  template_not_ends_with_nocase: String
  template_not_in: [String!]
  template_not_starts_with: String
  template_not_starts_with_nocase: String
  template_starts_with: String
  template_starts_with_nocase: String
  tokenUri: String
  tokenUri_contains: String
  tokenUri_contains_nocase: String
  tokenUri_ends_with: String
  tokenUri_ends_with_nocase: String
  tokenUri_gt: String
  tokenUri_gte: String
  tokenUri_in: [String!]
  tokenUri_lt: String
  tokenUri_lte: String
  tokenUri_not: String
  tokenUri_not_contains: String
  tokenUri_not_contains_nocase: String
  tokenUri_not_ends_with: String
  tokenUri_not_ends_with_nocase: String
  tokenUri_not_in: [String!]
  tokenUri_not_starts_with: String
  tokenUri_not_starts_with_nocase: String
  tokenUri_starts_with: String
  tokenUri_starts_with_nocase: String
  transferHistory_: NftTransferHistory_filter
  transferable: Boolean
  transferable_in: [Boolean!]
  transferable_not: Boolean
  transferable_not_in: [Boolean!]
  tx: String
  tx_contains: String
  tx_contains_nocase: String
  tx_ends_with: String
  tx_ends_with_nocase: String
  tx_gt: String
  tx_gte: String
  tx_in: [String!]
  tx_lt: String
  tx_lte: String
  tx_not: String
  tx_not_contains: String
  tx_not_contains_nocase: String
  tx_not_ends_with: String
  tx_not_ends_with_nocase: String
  tx_not_in: [String!]
  tx_not_starts_with: String
  tx_not_starts_with_nocase: String
  tx_starts_with: String
  tx_starts_with_nocase: String
}

enum Nft_orderBy {
  address
  assetState
  block
  createdTimestamp
  creator
  erc20DeployerRole
  eventIndex
  hasMetadata
  id
  managerRole
  metadataRole
  name
  nftData
  orderCount
  owner
  providerUrl
  storeUpdateRole
  symbol
  template
  tokenUri
  transferHistory
  transferable
  tx
}

type OPC {
  approvedTokens(first: Int = 100, orderBy: Token_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Token_filter): [Token!]
  id: ID!

  """fee in percent taken by OPC from orderFees"""
  orderFee: BigDecimal

  """fee in percent taken by OPC from providerFees"""
  providerFee: BigDecimal

  """fee in percent for swaps involving non OPC approved tokens"""
  swapNonOceanFee: BigDecimal

  """fee in percent for swaps involving OPC approved tokens"""
  swapOceanFee: BigDecimal
}

input OPC_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  approvedTokens: [String!]
  approvedTokens_: Token_filter
  approvedTokens_contains: [String!]
  approvedTokens_contains_nocase: [String!]
  approvedTokens_not: [String!]
  approvedTokens_not_contains: [String!]
  approvedTokens_not_contains_nocase: [String!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  orderFee: BigDecimal
  orderFee_gt: BigDecimal
  orderFee_gte: BigDecimal
  orderFee_in: [BigDecimal!]
  orderFee_lt: BigDecimal
  orderFee_lte: BigDecimal
  orderFee_not: BigDecimal
  orderFee_not_in: [BigDecimal!]
  providerFee: BigDecimal
  providerFee_gt: BigDecimal
  providerFee_gte: BigDecimal
  providerFee_in: [BigDecimal!]
  providerFee_lt: BigDecimal
  providerFee_lte: BigDecimal
  providerFee_not: BigDecimal
  providerFee_not_in: [BigDecimal!]
  swapNonOceanFee: BigDecimal
  swapNonOceanFee_gt: BigDecimal
  swapNonOceanFee_gte: BigDecimal
  swapNonOceanFee_in: [BigDecimal!]
  swapNonOceanFee_lt: BigDecimal
  swapNonOceanFee_lte: BigDecimal
  swapNonOceanFee_not: BigDecimal
  swapNonOceanFee_not_in: [BigDecimal!]
  swapOceanFee: BigDecimal
  swapOceanFee_gt: BigDecimal
  swapOceanFee_gte: BigDecimal
  swapOceanFee_in: [BigDecimal!]
  swapOceanFee_lt: BigDecimal
  swapOceanFee_lte: BigDecimal
  swapOceanFee_not: BigDecimal
  swapOceanFee_not_in: [BigDecimal!]
}

enum OPC_orderBy {
  approvedTokens
  id
  orderFee
  providerFee
  swapNonOceanFee
  swapOceanFee
}

type Order {
  amount: BigDecimal!
  block: Int!
  consumer: User!
  consumerMarket: User
  consumerMarketAmmount: BigDecimal
  consumerMarketToken: Token
  createdTimestamp: Int!
  datatoken: Token!
  estimatedUSDValue: BigDecimal!
  eventIndex: Int!

  """gas price in Wei"""
  gasPrice: BigInt
  gasUsed: BigDecimal

  """transaction hash - token address - from address - eventIndex"""
  id: ID!
  lastPriceToken: Token
  lastPriceValue: BigDecimal!
  nftOwner: User!
  payer: User!
  providerFee: String
  providerFeeValidUntil: BigInt
  publishingMarket: User
  publishingMarketAmmount: BigDecimal
  publishingMarketToken: Token
  reuses(first: Int = 100, orderBy: OrderReuse_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: OrderReuse_filter): [OrderReuse!]
  serviceIndex: Int!
  tx: String!
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type OrderReuse {
  block: Int!
  caller: String!
  createdTimestamp: Int!
  eventIndex: Int!

  """gas price in Wei"""
  gasPrice: BigInt
  gasUsed: BigDecimal
  id: ID!
  order: Order!
  providerFee: String
  providerFeeValidUntil: BigInt
  tx: String!
}

input OrderReuse_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  caller: String
  caller_contains: String
  caller_contains_nocase: String
  caller_ends_with: String
  caller_ends_with_nocase: String
  caller_gt: String
  caller_gte: String
  caller_in: [String!]
  caller_lt: String
  caller_lte: String
  caller_not: String
  caller_not_contains: String
  caller_not_contains_nocase: String
  caller_not_ends_with: String
  caller_not_ends_with_nocase: String
  caller_not_in: [String!]
  caller_not_starts_with: String
  caller_not_starts_with_nocase: String
  caller_starts_with: String
  caller_starts_with_nocase: String
  createdTimestamp: Int
  createdTimestamp_gt: Int
  createdTimestamp_gte: Int
  createdTimestamp_in: [Int!]
  createdTimestamp_lt: Int
  createdTimestamp_lte: Int
  createdTimestamp_not: Int
  createdTimestamp_not_in: [Int!]
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  gasPrice: BigInt
  gasPrice_gt: BigInt
  gasPrice_gte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_lt: BigInt
  gasPrice_lte: BigInt
  gasPrice_not: BigInt
  gasPrice_not_in: [BigInt!]
  gasUsed: BigDecimal
  gasUsed_gt: BigDecimal
  gasUsed_gte: BigDecimal
  gasUsed_in: [BigDecimal!]
  gasUsed_lt: BigDecimal
  gasUsed_lte: BigDecimal
  gasUsed_not: BigDecimal
  gasUsed_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  order: String
  order_: Order_filter
  order_contains: String
  order_contains_nocase: String
  order_ends_with: String
  order_ends_with_nocase: String
  order_gt: String
  order_gte: String
  order_in: [String!]
  order_lt: String
  order_lte: String
  order_not: String
  order_not_contains: String
  order_not_contains_nocase: String
  order_not_ends_with: String
  order_not_ends_with_nocase: String
  order_not_in: [String!]
  order_not_starts_with: String
  order_not_starts_with_nocase: String
  order_starts_with: String
  order_starts_with_nocase: String
  providerFee: String
  providerFeeValidUntil: BigInt
  providerFeeValidUntil_gt: BigInt
  providerFeeValidUntil_gte: BigInt
  providerFeeValidUntil_in: [BigInt!]
  providerFeeValidUntil_lt: BigInt
  providerFeeValidUntil_lte: BigInt
  providerFeeValidUntil_not: BigInt
  providerFeeValidUntil_not_in: [BigInt!]
  providerFee_contains: String
  providerFee_contains_nocase: String
  providerFee_ends_with: String
  providerFee_ends_with_nocase: String
  providerFee_gt: String
  providerFee_gte: String
  providerFee_in: [String!]
  providerFee_lt: String
  providerFee_lte: String
  providerFee_not: String
  providerFee_not_contains: String
  providerFee_not_contains_nocase: String
  providerFee_not_ends_with: String
  providerFee_not_ends_with_nocase: String
  providerFee_not_in: [String!]
  providerFee_not_starts_with: String
  providerFee_not_starts_with_nocase: String
  providerFee_starts_with: String
  providerFee_starts_with_nocase: String
  tx: String
  tx_contains: String
  tx_contains_nocase: String
  tx_ends_with: String
  tx_ends_with_nocase: String
  tx_gt: String
  tx_gte: String
  tx_in: [String!]
  tx_lt: String
  tx_lte: String
  tx_not: String
  tx_not_contains: String
  tx_not_contains_nocase: String
  tx_not_ends_with: String
  tx_not_ends_with_nocase: String
  tx_not_in: [String!]
  tx_not_starts_with: String
  tx_not_starts_with_nocase: String
  tx_starts_with: String
  tx_starts_with_nocase: String
}

enum OrderReuse_orderBy {
  block
  caller
  createdTimestamp
  eventIndex
  gasPrice
  gasUsed
  id
  order
  providerFee
  providerFeeValidUntil
  tx
}

input Order_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  consumer: String
  consumerMarket: String
  consumerMarketAmmount: BigDecimal
  consumerMarketAmmount_gt: BigDecimal
  consumerMarketAmmount_gte: BigDecimal
  consumerMarketAmmount_in: [BigDecimal!]
  consumerMarketAmmount_lt: BigDecimal
  consumerMarketAmmount_lte: BigDecimal
  consumerMarketAmmount_not: BigDecimal
  consumerMarketAmmount_not_in: [BigDecimal!]
  consumerMarketToken: String
  consumerMarketToken_: Token_filter
  consumerMarketToken_contains: String
  consumerMarketToken_contains_nocase: String
  consumerMarketToken_ends_with: String
  consumerMarketToken_ends_with_nocase: String
  consumerMarketToken_gt: String
  consumerMarketToken_gte: String
  consumerMarketToken_in: [String!]
  consumerMarketToken_lt: String
  consumerMarketToken_lte: String
  consumerMarketToken_not: String
  consumerMarketToken_not_contains: String
  consumerMarketToken_not_contains_nocase: String
  consumerMarketToken_not_ends_with: String
  consumerMarketToken_not_ends_with_nocase: String
  consumerMarketToken_not_in: [String!]
  consumerMarketToken_not_starts_with: String
  consumerMarketToken_not_starts_with_nocase: String
  consumerMarketToken_starts_with: String
  consumerMarketToken_starts_with_nocase: String
  consumerMarket_: User_filter
  consumerMarket_contains: String
  consumerMarket_contains_nocase: String
  consumerMarket_ends_with: String
  consumerMarket_ends_with_nocase: String
  consumerMarket_gt: String
  consumerMarket_gte: String
  consumerMarket_in: [String!]
  consumerMarket_lt: String
  consumerMarket_lte: String
  consumerMarket_not: String
  consumerMarket_not_contains: String
  consumerMarket_not_contains_nocase: String
  consumerMarket_not_ends_with: String
  consumerMarket_not_ends_with_nocase: String
  consumerMarket_not_in: [String!]
  consumerMarket_not_starts_with: String
  consumerMarket_not_starts_with_nocase: String
  consumerMarket_starts_with: String
  consumerMarket_starts_with_nocase: String
  consumer_: User_filter
  consumer_contains: String
  consumer_contains_nocase: String
  consumer_ends_with: String
  consumer_ends_with_nocase: String
  consumer_gt: String
  consumer_gte: String
  consumer_in: [String!]
  consumer_lt: String
  consumer_lte: String
  consumer_not: String
  consumer_not_contains: String
  consumer_not_contains_nocase: String
  consumer_not_ends_with: String
  consumer_not_ends_with_nocase: String
  consumer_not_in: [String!]
  consumer_not_starts_with: String
  consumer_not_starts_with_nocase: String
  consumer_starts_with: String
  consumer_starts_with_nocase: String
  createdTimestamp: Int
  createdTimestamp_gt: Int
  createdTimestamp_gte: Int
  createdTimestamp_in: [Int!]
  createdTimestamp_lt: Int
  createdTimestamp_lte: Int
  createdTimestamp_not: Int
  createdTimestamp_not_in: [Int!]
  datatoken: String
  datatoken_: Token_filter
  datatoken_contains: String
  datatoken_contains_nocase: String
  datatoken_ends_with: String
  datatoken_ends_with_nocase: String
  datatoken_gt: String
  datatoken_gte: String
  datatoken_in: [String!]
  datatoken_lt: String
  datatoken_lte: String
  datatoken_not: String
  datatoken_not_contains: String
  datatoken_not_contains_nocase: String
  datatoken_not_ends_with: String
  datatoken_not_ends_with_nocase: String
  datatoken_not_in: [String!]
  datatoken_not_starts_with: String
  datatoken_not_starts_with_nocase: String
  datatoken_starts_with: String
  datatoken_starts_with_nocase: String
  estimatedUSDValue: BigDecimal
  estimatedUSDValue_gt: BigDecimal
  estimatedUSDValue_gte: BigDecimal
  estimatedUSDValue_in: [BigDecimal!]
  estimatedUSDValue_lt: BigDecimal
  estimatedUSDValue_lte: BigDecimal
  estimatedUSDValue_not: BigDecimal
  estimatedUSDValue_not_in: [BigDecimal!]
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  gasPrice: BigInt
  gasPrice_gt: BigInt
  gasPrice_gte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_lt: BigInt
  gasPrice_lte: BigInt
  gasPrice_not: BigInt
  gasPrice_not_in: [BigInt!]
  gasUsed: BigDecimal
  gasUsed_gt: BigDecimal
  gasUsed_gte: BigDecimal
  gasUsed_in: [BigDecimal!]
  gasUsed_lt: BigDecimal
  gasUsed_lte: BigDecimal
  gasUsed_not: BigDecimal
  gasUsed_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastPriceToken: String
  lastPriceToken_: Token_filter
  lastPriceToken_contains: String
  lastPriceToken_contains_nocase: String
  lastPriceToken_ends_with: String
  lastPriceToken_ends_with_nocase: String
  lastPriceToken_gt: String
  lastPriceToken_gte: String
  lastPriceToken_in: [String!]
  lastPriceToken_lt: String
  lastPriceToken_lte: String
  lastPriceToken_not: String
  lastPriceToken_not_contains: String
  lastPriceToken_not_contains_nocase: String
  lastPriceToken_not_ends_with: String
  lastPriceToken_not_ends_with_nocase: String
  lastPriceToken_not_in: [String!]
  lastPriceToken_not_starts_with: String
  lastPriceToken_not_starts_with_nocase: String
  lastPriceToken_starts_with: String
  lastPriceToken_starts_with_nocase: String
  lastPriceValue: BigDecimal
  lastPriceValue_gt: BigDecimal
  lastPriceValue_gte: BigDecimal
  lastPriceValue_in: [BigDecimal!]
  lastPriceValue_lt: BigDecimal
  lastPriceValue_lte: BigDecimal
  lastPriceValue_not: BigDecimal
  lastPriceValue_not_in: [BigDecimal!]
  nftOwner: String
  nftOwner_: User_filter
  nftOwner_contains: String
  nftOwner_contains_nocase: String
  nftOwner_ends_with: String
  nftOwner_ends_with_nocase: String
  nftOwner_gt: String
  nftOwner_gte: String
  nftOwner_in: [String!]
  nftOwner_lt: String
  nftOwner_lte: String
  nftOwner_not: String
  nftOwner_not_contains: String
  nftOwner_not_contains_nocase: String
  nftOwner_not_ends_with: String
  nftOwner_not_ends_with_nocase: String
  nftOwner_not_in: [String!]
  nftOwner_not_starts_with: String
  nftOwner_not_starts_with_nocase: String
  nftOwner_starts_with: String
  nftOwner_starts_with_nocase: String
  payer: String
  payer_: User_filter
  payer_contains: String
  payer_contains_nocase: String
  payer_ends_with: String
  payer_ends_with_nocase: String
  payer_gt: String
  payer_gte: String
  payer_in: [String!]
  payer_lt: String
  payer_lte: String
  payer_not: String
  payer_not_contains: String
  payer_not_contains_nocase: String
  payer_not_ends_with: String
  payer_not_ends_with_nocase: String
  payer_not_in: [String!]
  payer_not_starts_with: String
  payer_not_starts_with_nocase: String
  payer_starts_with: String
  payer_starts_with_nocase: String
  providerFee: String
  providerFeeValidUntil: BigInt
  providerFeeValidUntil_gt: BigInt
  providerFeeValidUntil_gte: BigInt
  providerFeeValidUntil_in: [BigInt!]
  providerFeeValidUntil_lt: BigInt
  providerFeeValidUntil_lte: BigInt
  providerFeeValidUntil_not: BigInt
  providerFeeValidUntil_not_in: [BigInt!]
  providerFee_contains: String
  providerFee_contains_nocase: String
  providerFee_ends_with: String
  providerFee_ends_with_nocase: String
  providerFee_gt: String
  providerFee_gte: String
  providerFee_in: [String!]
  providerFee_lt: String
  providerFee_lte: String
  providerFee_not: String
  providerFee_not_contains: String
  providerFee_not_contains_nocase: String
  providerFee_not_ends_with: String
  providerFee_not_ends_with_nocase: String
  providerFee_not_in: [String!]
  providerFee_not_starts_with: String
  providerFee_not_starts_with_nocase: String
  providerFee_starts_with: String
  providerFee_starts_with_nocase: String
  publishingMarket: String
  publishingMarketAmmount: BigDecimal
  publishingMarketAmmount_gt: BigDecimal
  publishingMarketAmmount_gte: BigDecimal
  publishingMarketAmmount_in: [BigDecimal!]
  publishingMarketAmmount_lt: BigDecimal
  publishingMarketAmmount_lte: BigDecimal
  publishingMarketAmmount_not: BigDecimal
  publishingMarketAmmount_not_in: [BigDecimal!]
  publishingMarketToken: String
  publishingMarketToken_: Token_filter
  publishingMarketToken_contains: String
  publishingMarketToken_contains_nocase: String
  publishingMarketToken_ends_with: String
  publishingMarketToken_ends_with_nocase: String
  publishingMarketToken_gt: String
  publishingMarketToken_gte: String
  publishingMarketToken_in: [String!]
  publishingMarketToken_lt: String
  publishingMarketToken_lte: String
  publishingMarketToken_not: String
  publishingMarketToken_not_contains: String
  publishingMarketToken_not_contains_nocase: String
  publishingMarketToken_not_ends_with: String
  publishingMarketToken_not_ends_with_nocase: String
  publishingMarketToken_not_in: [String!]
  publishingMarketToken_not_starts_with: String
  publishingMarketToken_not_starts_with_nocase: String
  publishingMarketToken_starts_with: String
  publishingMarketToken_starts_with_nocase: String
  publishingMarket_: User_filter
  publishingMarket_contains: String
  publishingMarket_contains_nocase: String
  publishingMarket_ends_with: String
  publishingMarket_ends_with_nocase: String
  publishingMarket_gt: String
  publishingMarket_gte: String
  publishingMarket_in: [String!]
  publishingMarket_lt: String
  publishingMarket_lte: String
  publishingMarket_not: String
  publishingMarket_not_contains: String
  publishingMarket_not_contains_nocase: String
  publishingMarket_not_ends_with: String
  publishingMarket_not_ends_with_nocase: String
  publishingMarket_not_in: [String!]
  publishingMarket_not_starts_with: String
  publishingMarket_not_starts_with_nocase: String
  publishingMarket_starts_with: String
  publishingMarket_starts_with_nocase: String
  reuses_: OrderReuse_filter
  serviceIndex: Int
  serviceIndex_gt: Int
  serviceIndex_gte: Int
  serviceIndex_in: [Int!]
  serviceIndex_lt: Int
  serviceIndex_lte: Int
  serviceIndex_not: Int
  serviceIndex_not_in: [Int!]
  tx: String
  tx_contains: String
  tx_contains_nocase: String
  tx_ends_with: String
  tx_ends_with_nocase: String
  tx_gt: String
  tx_gte: String
  tx_in: [String!]
  tx_lt: String
  tx_lte: String
  tx_not: String
  tx_not_contains: String
  tx_not_contains_nocase: String
  tx_not_ends_with: String
  tx_not_ends_with_nocase: String
  tx_not_in: [String!]
  tx_not_starts_with: String
  tx_not_starts_with_nocase: String
  tx_starts_with: String
  tx_starts_with_nocase: String
}

enum Order_orderBy {
  amount
  block
  consumer
  consumerMarket
  consumerMarketAmmount
  consumerMarketToken
  createdTimestamp
  datatoken
  estimatedUSDValue
  eventIndex
  gasPrice
  gasUsed
  id
  lastPriceToken
  lastPriceValue
  nftOwner
  payer
  providerFee
  providerFeeValidUntil
  publishingMarket
  publishingMarketAmmount
  publishingMarketToken
  reuses
  serviceIndex
  tx
}

type Query {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  dfavailableClaim(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DFAvailableClaim
  dfavailableClaims(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DFAvailableClaim_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DFAvailableClaim_filter
  ): [DFAvailableClaim!]!
  dfhistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DFHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DFHistory_filter
  ): [DFHistory!]!
  dfhistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DFHistory
  dfreward(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DFReward
  dfrewards(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DFReward_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DFReward_filter
  ): [DFReward!]!
  dispenser(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Dispenser
  dispenserTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DispenserTransaction
  dispenserTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DispenserTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DispenserTransaction_filter
  ): [DispenserTransaction!]!
  dispensers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Dispenser_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Dispenser_filter
  ): [Dispenser!]!
  fixedRateExchange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FixedRateExchange
  fixedRateExchangeSwap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FixedRateExchangeSwap
  fixedRateExchangeSwaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FixedRateExchangeSwap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FixedRateExchangeSwap_filter
  ): [FixedRateExchangeSwap!]!
  fixedRateExchangeUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FixedRateExchangeUpdate
  fixedRateExchangeUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FixedRateExchangeUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FixedRateExchangeUpdate_filter
  ): [FixedRateExchangeUpdate!]!
  fixedRateExchanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FixedRateExchange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FixedRateExchange_filter
  ): [FixedRateExchange!]!
  globalStatistic(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GlobalStatistic
  globalStatistics(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GlobalStatistic_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GlobalStatistic_filter
  ): [GlobalStatistic!]!
  globalTotalFixedSwapPair(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GlobalTotalFixedSwapPair
  globalTotalFixedSwapPairs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GlobalTotalFixedSwapPair_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GlobalTotalFixedSwapPair_filter
  ): [GlobalTotalFixedSwapPair!]!
  globalTotalLiquidityPair(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GlobalTotalLiquidityPair
  globalTotalLiquidityPairs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GlobalTotalLiquidityPair_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GlobalTotalLiquidityPair_filter
  ): [GlobalTotalLiquidityPair!]!
  nft(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Nft
  nftData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NftData
  nftDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NftData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NftData_filter
  ): [NftData!]!
  nftTransferHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NftTransferHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NftTransferHistory_filter
  ): [NftTransferHistory!]!
  nftTransferHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NftTransferHistory
  nftUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NftUpdate
  nftUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NftUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NftUpdate_filter
  ): [NftUpdate!]!
  nfts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Nft_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Nft_filter
  ): [Nft!]!
  opc(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OPC
  opcs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OPC_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OPC_filter
  ): [OPC!]!
  order(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Order
  orderReuse(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OrderReuse
  orderReuses(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OrderReuse_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OrderReuse_filter
  ): [OrderReuse!]!
  orders(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Order_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Order_filter
  ): [Order!]!
  template(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Template
  templates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Template_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Template_filter
  ): [Template!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokenValuePair(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenValuePair
  tokenValuePairs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenValuePair_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenValuePair_filter
  ): [TokenValuePair!]!
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
  veAllocateId(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeAllocateId
  veAllocateIds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeAllocateId_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeAllocateId_filter
  ): [VeAllocateId!]!
  veAllocateUser(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeAllocateUser
  veAllocateUsers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeAllocateUser_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeAllocateUser_filter
  ): [VeAllocateUser!]!
  veAllocation(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeAllocation
  veAllocationUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeAllocationUpdate
  veAllocationUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeAllocationUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeAllocationUpdate_filter
  ): [VeAllocationUpdate!]!
  veAllocations(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeAllocation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeAllocation_filter
  ): [VeAllocation!]!
  veClaim(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeClaim
  veClaims(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeClaim_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeClaim_filter
  ): [VeClaim!]!
  veDelegation(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeDelegation
  veDelegationUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeDelegationUpdate
  veDelegationUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeDelegationUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeDelegationUpdate_filter
  ): [VeDelegationUpdate!]!
  veDelegations(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeDelegation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeDelegation_filter
  ): [VeDelegation!]!
  veDeposit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeDeposit
  veDeposits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeDeposit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeDeposit_filter
  ): [VeDeposit!]!
  veFeeDistributor(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeFeeDistributor
  veFeeDistributorCheckPoint(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeFeeDistributorCheckPoint
  veFeeDistributorCheckPoints(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeFeeDistributorCheckPoint_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeFeeDistributorCheckPoint_filter
  ): [VeFeeDistributorCheckPoint!]!
  veFeeDistributors(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeFeeDistributor_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeFeeDistributor_filter
  ): [VeFeeDistributor!]!
  veOCEAN(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeOCEAN
  veOCEANs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeOCEAN_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeOCEAN_filter
  ): [VeOCEAN!]!
}

type Subscription {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  dfavailableClaim(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DFAvailableClaim
  dfavailableClaims(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DFAvailableClaim_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DFAvailableClaim_filter
  ): [DFAvailableClaim!]!
  dfhistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DFHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DFHistory_filter
  ): [DFHistory!]!
  dfhistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DFHistory
  dfreward(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DFReward
  dfrewards(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DFReward_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DFReward_filter
  ): [DFReward!]!
  dispenser(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Dispenser
  dispenserTransaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DispenserTransaction
  dispenserTransactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: DispenserTransaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: DispenserTransaction_filter
  ): [DispenserTransaction!]!
  dispensers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Dispenser_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Dispenser_filter
  ): [Dispenser!]!
  fixedRateExchange(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FixedRateExchange
  fixedRateExchangeSwap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FixedRateExchangeSwap
  fixedRateExchangeSwaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FixedRateExchangeSwap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FixedRateExchangeSwap_filter
  ): [FixedRateExchangeSwap!]!
  fixedRateExchangeUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FixedRateExchangeUpdate
  fixedRateExchangeUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FixedRateExchangeUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FixedRateExchangeUpdate_filter
  ): [FixedRateExchangeUpdate!]!
  fixedRateExchanges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FixedRateExchange_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FixedRateExchange_filter
  ): [FixedRateExchange!]!
  globalStatistic(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GlobalStatistic
  globalStatistics(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GlobalStatistic_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GlobalStatistic_filter
  ): [GlobalStatistic!]!
  globalTotalFixedSwapPair(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GlobalTotalFixedSwapPair
  globalTotalFixedSwapPairs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GlobalTotalFixedSwapPair_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GlobalTotalFixedSwapPair_filter
  ): [GlobalTotalFixedSwapPair!]!
  globalTotalLiquidityPair(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GlobalTotalLiquidityPair
  globalTotalLiquidityPairs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GlobalTotalLiquidityPair_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GlobalTotalLiquidityPair_filter
  ): [GlobalTotalLiquidityPair!]!
  nft(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Nft
  nftData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NftData
  nftDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NftData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NftData_filter
  ): [NftData!]!
  nftTransferHistories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NftTransferHistory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NftTransferHistory_filter
  ): [NftTransferHistory!]!
  nftTransferHistory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NftTransferHistory
  nftUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NftUpdate
  nftUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: NftUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: NftUpdate_filter
  ): [NftUpdate!]!
  nfts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Nft_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Nft_filter
  ): [Nft!]!
  opc(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OPC
  opcs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OPC_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OPC_filter
  ): [OPC!]!
  order(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Order
  orderReuse(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OrderReuse
  orderReuses(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OrderReuse_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OrderReuse_filter
  ): [OrderReuse!]!
  orders(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Order_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Order_filter
  ): [Order!]!
  template(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Template
  templates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Template_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Template_filter
  ): [Template!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokenValuePair(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenValuePair
  tokenValuePairs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenValuePair_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenValuePair_filter
  ): [TokenValuePair!]!
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
  veAllocateId(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeAllocateId
  veAllocateIds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeAllocateId_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeAllocateId_filter
  ): [VeAllocateId!]!
  veAllocateUser(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeAllocateUser
  veAllocateUsers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeAllocateUser_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeAllocateUser_filter
  ): [VeAllocateUser!]!
  veAllocation(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeAllocation
  veAllocationUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeAllocationUpdate
  veAllocationUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeAllocationUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeAllocationUpdate_filter
  ): [VeAllocationUpdate!]!
  veAllocations(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeAllocation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeAllocation_filter
  ): [VeAllocation!]!
  veClaim(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeClaim
  veClaims(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeClaim_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeClaim_filter
  ): [VeClaim!]!
  veDelegation(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeDelegation
  veDelegationUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeDelegationUpdate
  veDelegationUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeDelegationUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeDelegationUpdate_filter
  ): [VeDelegationUpdate!]!
  veDelegations(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeDelegation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeDelegation_filter
  ): [VeDelegation!]!
  veDeposit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeDeposit
  veDeposits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeDeposit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeDeposit_filter
  ): [VeDeposit!]!
  veFeeDistributor(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeFeeDistributor
  veFeeDistributorCheckPoint(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeFeeDistributorCheckPoint
  veFeeDistributorCheckPoints(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeFeeDistributorCheckPoint_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeFeeDistributorCheckPoint_filter
  ): [VeFeeDistributorCheckPoint!]!
  veFeeDistributors(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeFeeDistributor_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeFeeDistributor_filter
  ): [VeFeeDistributor!]!
  veOCEAN(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VeOCEAN
  veOCEANs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VeOCEAN_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VeOCEAN_filter
  ): [VeOCEAN!]!
}

type Template {
  dispenserTemplates: [String!]
  fixedRateTemplates: [String!]
  id: ID!
  ssTemplates: [String!]
}

input Template_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  dispenserTemplates: [String!]
  dispenserTemplates_contains: [String!]
  dispenserTemplates_contains_nocase: [String!]
  dispenserTemplates_not: [String!]
  dispenserTemplates_not_contains: [String!]
  dispenserTemplates_not_contains_nocase: [String!]
  fixedRateTemplates: [String!]
  fixedRateTemplates_contains: [String!]
  fixedRateTemplates_contains_nocase: [String!]
  fixedRateTemplates_not: [String!]
  fixedRateTemplates_not_contains: [String!]
  fixedRateTemplates_not_contains_nocase: [String!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  ssTemplates: [String!]
  ssTemplates_contains: [String!]
  ssTemplates_contains_nocase: [String!]
  ssTemplates_not: [String!]
  ssTemplates_not_contains: [String!]
  ssTemplates_not_contains_nocase: [String!]
}

enum Template_orderBy {
  dispenserTemplates
  fixedRateTemplates
  id
  ssTemplates
}

type Token {
  address: String!

  """block number when it was created"""
  block: Int!
  cap: BigDecimal

  """block time datatoken was created"""
  createdTimestamp: Int!
  decimals: Int!

  """dispensers using this token"""
  dispensers(first: Int = 100, orderBy: Dispenser_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Dispenser_filter): [Dispenser!]
  eventIndex: Int!

  """fixed rate exchanges, only available for datatokens"""
  fixedRateExchanges(first: Int = 100, orderBy: FixedRateExchange_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: FixedRateExchange_filter): [FixedRateExchange!]

  """
  number of addresses holding a balance of datatoken , TODO: can we actually calculate this? what happens when users trade the dts
  """
  holderCount: BigInt!
  id: ID!
  isDatatoken: Boolean!
  lastPriceToken: Token
  lastPriceValue: BigDecimal!

  """array of addresses with minter role"""
  minter: [String!]
  name: String

  """address of ERC721 that owns the token, valid only for datatokens"""
  nft: Nft

  """number of orders executed for this datatoken"""
  orderCount: BigInt!

  """orders created with the datatoken, only available for datatokens"""
  orders(first: Int = 100, orderBy: Order_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Order_filter): [Order!]

  """address that collects the payments (NOT fees)"""
  paymentCollector: String

  """array of addresses with payment manager minter role"""
  paymentManager: [String!]

  """
  address of the market where the datatoken was created. This address collects market fees.
  """
  publishMarketFeeAddress: String

  """fee amount. Fixed value."""
  publishMarketFeeAmount: BigDecimal

  """adreess of fee token (can be Ocean, ETH, etc.)"""
  publishMarketFeeToken: String
  supply: BigDecimal
  symbol: String

  """template ID of the datatoken"""
  templateId: Int

  """datatoken creation transaction id"""
  tx: String!
}

"""utility type"""
type TokenValuePair {
  """address of the token"""
  id: ID!
  token: Token!
  value: BigDecimal!
}

input TokenValuePair_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  value: BigDecimal
  value_gt: BigDecimal
  value_gte: BigDecimal
  value_in: [BigDecimal!]
  value_lt: BigDecimal
  value_lte: BigDecimal
  value_not: BigDecimal
  value_not_in: [BigDecimal!]
}

enum TokenValuePair_orderBy {
  id
  token
  value
}

input Token_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  address: String
  address_contains: String
  address_contains_nocase: String
  address_ends_with: String
  address_ends_with_nocase: String
  address_gt: String
  address_gte: String
  address_in: [String!]
  address_lt: String
  address_lte: String
  address_not: String
  address_not_contains: String
  address_not_contains_nocase: String
  address_not_ends_with: String
  address_not_ends_with_nocase: String
  address_not_in: [String!]
  address_not_starts_with: String
  address_not_starts_with_nocase: String
  address_starts_with: String
  address_starts_with_nocase: String
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  cap: BigDecimal
  cap_gt: BigDecimal
  cap_gte: BigDecimal
  cap_in: [BigDecimal!]
  cap_lt: BigDecimal
  cap_lte: BigDecimal
  cap_not: BigDecimal
  cap_not_in: [BigDecimal!]
  createdTimestamp: Int
  createdTimestamp_gt: Int
  createdTimestamp_gte: Int
  createdTimestamp_in: [Int!]
  createdTimestamp_lt: Int
  createdTimestamp_lte: Int
  createdTimestamp_not: Int
  createdTimestamp_not_in: [Int!]
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  dispensers_: Dispenser_filter
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  fixedRateExchanges_: FixedRateExchange_filter
  holderCount: BigInt
  holderCount_gt: BigInt
  holderCount_gte: BigInt
  holderCount_in: [BigInt!]
  holderCount_lt: BigInt
  holderCount_lte: BigInt
  holderCount_not: BigInt
  holderCount_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isDatatoken: Boolean
  isDatatoken_in: [Boolean!]
  isDatatoken_not: Boolean
  isDatatoken_not_in: [Boolean!]
  lastPriceToken: String
  lastPriceToken_: Token_filter
  lastPriceToken_contains: String
  lastPriceToken_contains_nocase: String
  lastPriceToken_ends_with: String
  lastPriceToken_ends_with_nocase: String
  lastPriceToken_gt: String
  lastPriceToken_gte: String
  lastPriceToken_in: [String!]
  lastPriceToken_lt: String
  lastPriceToken_lte: String
  lastPriceToken_not: String
  lastPriceToken_not_contains: String
  lastPriceToken_not_contains_nocase: String
  lastPriceToken_not_ends_with: String
  lastPriceToken_not_ends_with_nocase: String
  lastPriceToken_not_in: [String!]
  lastPriceToken_not_starts_with: String
  lastPriceToken_not_starts_with_nocase: String
  lastPriceToken_starts_with: String
  lastPriceToken_starts_with_nocase: String
  lastPriceValue: BigDecimal
  lastPriceValue_gt: BigDecimal
  lastPriceValue_gte: BigDecimal
  lastPriceValue_in: [BigDecimal!]
  lastPriceValue_lt: BigDecimal
  lastPriceValue_lte: BigDecimal
  lastPriceValue_not: BigDecimal
  lastPriceValue_not_in: [BigDecimal!]
  minter: [String!]
  minter_contains: [String!]
  minter_contains_nocase: [String!]
  minter_not: [String!]
  minter_not_contains: [String!]
  minter_not_contains_nocase: [String!]
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  nft: String
  nft_: Nft_filter
  nft_contains: String
  nft_contains_nocase: String
  nft_ends_with: String
  nft_ends_with_nocase: String
  nft_gt: String
  nft_gte: String
  nft_in: [String!]
  nft_lt: String
  nft_lte: String
  nft_not: String
  nft_not_contains: String
  nft_not_contains_nocase: String
  nft_not_ends_with: String
  nft_not_ends_with_nocase: String
  nft_not_in: [String!]
  nft_not_starts_with: String
  nft_not_starts_with_nocase: String
  nft_starts_with: String
  nft_starts_with_nocase: String
  orderCount: BigInt
  orderCount_gt: BigInt
  orderCount_gte: BigInt
  orderCount_in: [BigInt!]
  orderCount_lt: BigInt
  orderCount_lte: BigInt
  orderCount_not: BigInt
  orderCount_not_in: [BigInt!]
  orders_: Order_filter
  paymentCollector: String
  paymentCollector_contains: String
  paymentCollector_contains_nocase: String
  paymentCollector_ends_with: String
  paymentCollector_ends_with_nocase: String
  paymentCollector_gt: String
  paymentCollector_gte: String
  paymentCollector_in: [String!]
  paymentCollector_lt: String
  paymentCollector_lte: String
  paymentCollector_not: String
  paymentCollector_not_contains: String
  paymentCollector_not_contains_nocase: String
  paymentCollector_not_ends_with: String
  paymentCollector_not_ends_with_nocase: String
  paymentCollector_not_in: [String!]
  paymentCollector_not_starts_with: String
  paymentCollector_not_starts_with_nocase: String
  paymentCollector_starts_with: String
  paymentCollector_starts_with_nocase: String
  paymentManager: [String!]
  paymentManager_contains: [String!]
  paymentManager_contains_nocase: [String!]
  paymentManager_not: [String!]
  paymentManager_not_contains: [String!]
  paymentManager_not_contains_nocase: [String!]
  publishMarketFeeAddress: String
  publishMarketFeeAddress_contains: String
  publishMarketFeeAddress_contains_nocase: String
  publishMarketFeeAddress_ends_with: String
  publishMarketFeeAddress_ends_with_nocase: String
  publishMarketFeeAddress_gt: String
  publishMarketFeeAddress_gte: String
  publishMarketFeeAddress_in: [String!]
  publishMarketFeeAddress_lt: String
  publishMarketFeeAddress_lte: String
  publishMarketFeeAddress_not: String
  publishMarketFeeAddress_not_contains: String
  publishMarketFeeAddress_not_contains_nocase: String
  publishMarketFeeAddress_not_ends_with: String
  publishMarketFeeAddress_not_ends_with_nocase: String
  publishMarketFeeAddress_not_in: [String!]
  publishMarketFeeAddress_not_starts_with: String
  publishMarketFeeAddress_not_starts_with_nocase: String
  publishMarketFeeAddress_starts_with: String
  publishMarketFeeAddress_starts_with_nocase: String
  publishMarketFeeAmount: BigDecimal
  publishMarketFeeAmount_gt: BigDecimal
  publishMarketFeeAmount_gte: BigDecimal
  publishMarketFeeAmount_in: [BigDecimal!]
  publishMarketFeeAmount_lt: BigDecimal
  publishMarketFeeAmount_lte: BigDecimal
  publishMarketFeeAmount_not: BigDecimal
  publishMarketFeeAmount_not_in: [BigDecimal!]
  publishMarketFeeToken: String
  publishMarketFeeToken_contains: String
  publishMarketFeeToken_contains_nocase: String
  publishMarketFeeToken_ends_with: String
  publishMarketFeeToken_ends_with_nocase: String
  publishMarketFeeToken_gt: String
  publishMarketFeeToken_gte: String
  publishMarketFeeToken_in: [String!]
  publishMarketFeeToken_lt: String
  publishMarketFeeToken_lte: String
  publishMarketFeeToken_not: String
  publishMarketFeeToken_not_contains: String
  publishMarketFeeToken_not_contains_nocase: String
  publishMarketFeeToken_not_ends_with: String
  publishMarketFeeToken_not_ends_with_nocase: String
  publishMarketFeeToken_not_in: [String!]
  publishMarketFeeToken_not_starts_with: String
  publishMarketFeeToken_not_starts_with_nocase: String
  publishMarketFeeToken_starts_with: String
  publishMarketFeeToken_starts_with_nocase: String
  supply: BigDecimal
  supply_gt: BigDecimal
  supply_gte: BigDecimal
  supply_in: [BigDecimal!]
  supply_lt: BigDecimal
  supply_lte: BigDecimal
  supply_not: BigDecimal
  supply_not_in: [BigDecimal!]
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  templateId: Int
  templateId_gt: Int
  templateId_gte: Int
  templateId_in: [Int!]
  templateId_lt: Int
  templateId_lte: Int
  templateId_not: Int
  templateId_not_in: [Int!]
  tx: String
  tx_contains: String
  tx_contains_nocase: String
  tx_ends_with: String
  tx_ends_with_nocase: String
  tx_gt: String
  tx_gte: String
  tx_in: [String!]
  tx_lt: String
  tx_lte: String
  tx_not: String
  tx_not_contains: String
  tx_not_contains_nocase: String
  tx_not_ends_with: String
  tx_not_ends_with_nocase: String
  tx_not_in: [String!]
  tx_not_starts_with: String
  tx_not_starts_with_nocase: String
  tx_starts_with: String
  tx_starts_with_nocase: String
}

enum Token_orderBy {
  address
  block
  cap
  createdTimestamp
  decimals
  dispensers
  eventIndex
  fixedRateExchanges
  holderCount
  id
  isDatatoken
  lastPriceToken
  lastPriceValue
  minter
  name
  nft
  orderCount
  orders
  paymentCollector
  paymentManager
  publishMarketFeeAddress
  publishMarketFeeAmount
  publishMarketFeeToken
  supply
  symbol
  templateId
  tx
}

type User {
  freSwaps(first: Int = 100, orderBy: FixedRateExchangeSwap_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: FixedRateExchangeSwap_filter): [FixedRateExchangeSwap!]
  id: ID!
  orders(first: Int = 100, orderBy: Order_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Order_filter): [Order!]
  tokenBalancesOwned(first: Int = 100, orderBy: TokenValuePair_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TokenValuePair_filter): [TokenValuePair!]

  """total number of orders made by this user"""
  totalOrders: BigInt!

  """total number of orders made on assets owned by this user"""
  totalSales: BigInt!
}

input User_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  freSwaps_: FixedRateExchangeSwap_filter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  orders_: Order_filter
  tokenBalancesOwned: [String!]
  tokenBalancesOwned_: TokenValuePair_filter
  tokenBalancesOwned_contains: [String!]
  tokenBalancesOwned_contains_nocase: [String!]
  tokenBalancesOwned_not: [String!]
  tokenBalancesOwned_not_contains: [String!]
  tokenBalancesOwned_not_contains_nocase: [String!]
  totalOrders: BigInt
  totalOrders_gt: BigInt
  totalOrders_gte: BigInt
  totalOrders_in: [BigInt!]
  totalOrders_lt: BigInt
  totalOrders_lte: BigInt
  totalOrders_not: BigInt
  totalOrders_not_in: [BigInt!]
  totalSales: BigInt
  totalSales_gt: BigInt
  totalSales_gte: BigInt
  totalSales_in: [BigInt!]
  totalSales_lt: BigInt
  totalSales_lte: BigInt
  totalSales_not: BigInt
  totalSales_not_in: [BigInt!]
}

enum User_orderBy {
  freSwaps
  id
  orders
  tokenBalancesOwned
  totalOrders
  totalSales
}

type VeAllocateId {
  allocatedTotal: BigDecimal!
  block: Int!
  chainId: BigInt!
  eventIndex: Int!
  firstContact: Int!

  """id = {DataNFT Address}-{chain id}"""
  id: ID!
  lastContact: Int!
  nftAddress: String!
  tx: String!
  veAllocation(first: Int = 100, orderBy: VeAllocation_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: VeAllocation_filter): [VeAllocation!]
}

input VeAllocateId_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  allocatedTotal: BigDecimal
  allocatedTotal_gt: BigDecimal
  allocatedTotal_gte: BigDecimal
  allocatedTotal_in: [BigDecimal!]
  allocatedTotal_lt: BigDecimal
  allocatedTotal_lte: BigDecimal
  allocatedTotal_not: BigDecimal
  allocatedTotal_not_in: [BigDecimal!]
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  chainId: BigInt
  chainId_gt: BigInt
  chainId_gte: BigInt
  chainId_in: [BigInt!]
  chainId_lt: BigInt
  chainId_lte: BigInt
  chainId_not: BigInt
  chainId_not_in: [BigInt!]
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  firstContact: Int
  firstContact_gt: Int
  firstContact_gte: Int
  firstContact_in: [Int!]
  firstContact_lt: Int
  firstContact_lte: Int
  firstContact_not: Int
  firstContact_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastContact: Int
  lastContact_gt: Int
  lastContact_gte: Int
  lastContact_in: [Int!]
  lastContact_lt: Int
  lastContact_lte: Int
  lastContact_not: Int
  lastContact_not_in: [Int!]
  nftAddress: String
  nftAddress_contains: String
  nftAddress_contains_nocase: String
  nftAddress_ends_with: String
  nftAddress_ends_with_nocase: String
  nftAddress_gt: String
  nftAddress_gte: String
  nftAddress_in: [String!]
  nftAddress_lt: String
  nftAddress_lte: String
  nftAddress_not: String
  nftAddress_not_contains: String
  nftAddress_not_contains_nocase: String
  nftAddress_not_ends_with: String
  nftAddress_not_ends_with_nocase: String
  nftAddress_not_in: [String!]
  nftAddress_not_starts_with: String
  nftAddress_not_starts_with_nocase: String
  nftAddress_starts_with: String
  nftAddress_starts_with_nocase: String
  tx: String
  tx_contains: String
  tx_contains_nocase: String
  tx_ends_with: String
  tx_ends_with_nocase: String
  tx_gt: String
  tx_gte: String
  tx_in: [String!]
  tx_lt: String
  tx_lte: String
  tx_not: String
  tx_not_contains: String
  tx_not_contains_nocase: String
  tx_not_ends_with: String
  tx_not_ends_with_nocase: String
  tx_not_in: [String!]
  tx_not_starts_with: String
  tx_not_starts_with_nocase: String
  tx_starts_with: String
  tx_starts_with_nocase: String
  veAllocation_: VeAllocation_filter
}

enum VeAllocateId_orderBy {
  allocatedTotal
  block
  chainId
  eventIndex
  firstContact
  id
  lastContact
  nftAddress
  tx
  veAllocation
}

type VeAllocateUser {
  allocatedTotal: BigDecimal!
  block: Int!
  eventIndex: Int!
  firstContact: Int!

  """id = {user}"""
  id: ID!
  lastContact: Int!
  tx: String!
  veAllocation(first: Int = 100, orderBy: VeAllocation_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: VeAllocation_filter): [VeAllocation!]
  veOcean: VeOCEAN!
}

input VeAllocateUser_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  allocatedTotal: BigDecimal
  allocatedTotal_gt: BigDecimal
  allocatedTotal_gte: BigDecimal
  allocatedTotal_in: [BigDecimal!]
  allocatedTotal_lt: BigDecimal
  allocatedTotal_lte: BigDecimal
  allocatedTotal_not: BigDecimal
  allocatedTotal_not_in: [BigDecimal!]
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  firstContact: Int
  firstContact_gt: Int
  firstContact_gte: Int
  firstContact_in: [Int!]
  firstContact_lt: Int
  firstContact_lte: Int
  firstContact_not: Int
  firstContact_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastContact: Int
  lastContact_gt: Int
  lastContact_gte: Int
  lastContact_in: [Int!]
  lastContact_lt: Int
  lastContact_lte: Int
  lastContact_not: Int
  lastContact_not_in: [Int!]
  tx: String
  tx_contains: String
  tx_contains_nocase: String
  tx_ends_with: String
  tx_ends_with_nocase: String
  tx_gt: String
  tx_gte: String
  tx_in: [String!]
  tx_lt: String
  tx_lte: String
  tx_not: String
  tx_not_contains: String
  tx_not_contains_nocase: String
  tx_not_ends_with: String
  tx_not_ends_with_nocase: String
  tx_not_in: [String!]
  tx_not_starts_with: String
  tx_not_starts_with_nocase: String
  tx_starts_with: String
  tx_starts_with_nocase: String
  veAllocation_: VeAllocation_filter
  veOcean: String
  veOcean_: VeOCEAN_filter
  veOcean_contains: String
  veOcean_contains_nocase: String
  veOcean_ends_with: String
  veOcean_ends_with_nocase: String
  veOcean_gt: String
  veOcean_gte: String
  veOcean_in: [String!]
  veOcean_lt: String
  veOcean_lte: String
  veOcean_not: String
  veOcean_not_contains: String
  veOcean_not_contains_nocase: String
  veOcean_not_ends_with: String
  veOcean_not_ends_with_nocase: String
  veOcean_not_in: [String!]
  veOcean_not_starts_with: String
  veOcean_not_starts_with_nocase: String
  veOcean_starts_with: String
  veOcean_starts_with_nocase: String
}

enum VeAllocateUser_orderBy {
  allocatedTotal
  block
  eventIndex
  firstContact
  id
  lastContact
  tx
  veAllocation
  veOcean
}

type VeAllocation {
  allocated: BigDecimal!
  allocationId: VeAllocateId!
  allocationUser: VeAllocateUser!
  block: Int!
  chainId: BigInt!
  eventIndex: Int!
  firstContact: Int!

  """id = {user}-{DataNFT Address}-{chain id}"""
  id: ID!
  lastContact: Int!
  nftAddress: String!
  tx: String!
  updates(first: Int = 100, orderBy: VeAllocationUpdate_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: VeAllocationUpdate_filter): [VeAllocationUpdate!]
}

type VeAllocationUpdate {
  allocatedTotal: BigDecimal!
  block: Int!
  eventIndex: Int!

  """{tx}-{VeAllocation id}-{eventIndex}"""
  id: ID!
  timestamp: Int!
  tx: String!
  type: veAllocationUpdateType!
  veAllocation: VeAllocation!
}

input VeAllocationUpdate_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  allocatedTotal: BigDecimal
  allocatedTotal_gt: BigDecimal
  allocatedTotal_gte: BigDecimal
  allocatedTotal_in: [BigDecimal!]
  allocatedTotal_lt: BigDecimal
  allocatedTotal_lte: BigDecimal
  allocatedTotal_not: BigDecimal
  allocatedTotal_not_in: [BigDecimal!]
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  tx: String
  tx_contains: String
  tx_contains_nocase: String
  tx_ends_with: String
  tx_ends_with_nocase: String
  tx_gt: String
  tx_gte: String
  tx_in: [String!]
  tx_lt: String
  tx_lte: String
  tx_not: String
  tx_not_contains: String
  tx_not_contains_nocase: String
  tx_not_ends_with: String
  tx_not_ends_with_nocase: String
  tx_not_in: [String!]
  tx_not_starts_with: String
  tx_not_starts_with_nocase: String
  tx_starts_with: String
  tx_starts_with_nocase: String
  type: veAllocationUpdateType
  type_in: [veAllocationUpdateType!]
  type_not: veAllocationUpdateType
  type_not_in: [veAllocationUpdateType!]
  veAllocation: String
  veAllocation_: VeAllocation_filter
  veAllocation_contains: String
  veAllocation_contains_nocase: String
  veAllocation_ends_with: String
  veAllocation_ends_with_nocase: String
  veAllocation_gt: String
  veAllocation_gte: String
  veAllocation_in: [String!]
  veAllocation_lt: String
  veAllocation_lte: String
  veAllocation_not: String
  veAllocation_not_contains: String
  veAllocation_not_contains_nocase: String
  veAllocation_not_ends_with: String
  veAllocation_not_ends_with_nocase: String
  veAllocation_not_in: [String!]
  veAllocation_not_starts_with: String
  veAllocation_not_starts_with_nocase: String
  veAllocation_starts_with: String
  veAllocation_starts_with_nocase: String
}

enum VeAllocationUpdate_orderBy {
  allocatedTotal
  block
  eventIndex
  id
  timestamp
  tx
  type
  veAllocation
}

input VeAllocation_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  allocated: BigDecimal
  allocated_gt: BigDecimal
  allocated_gte: BigDecimal
  allocated_in: [BigDecimal!]
  allocated_lt: BigDecimal
  allocated_lte: BigDecimal
  allocated_not: BigDecimal
  allocated_not_in: [BigDecimal!]
  allocationId: String
  allocationId_: VeAllocateId_filter
  allocationId_contains: String
  allocationId_contains_nocase: String
  allocationId_ends_with: String
  allocationId_ends_with_nocase: String
  allocationId_gt: String
  allocationId_gte: String
  allocationId_in: [String!]
  allocationId_lt: String
  allocationId_lte: String
  allocationId_not: String
  allocationId_not_contains: String
  allocationId_not_contains_nocase: String
  allocationId_not_ends_with: String
  allocationId_not_ends_with_nocase: String
  allocationId_not_in: [String!]
  allocationId_not_starts_with: String
  allocationId_not_starts_with_nocase: String
  allocationId_starts_with: String
  allocationId_starts_with_nocase: String
  allocationUser: String
  allocationUser_: VeAllocateUser_filter
  allocationUser_contains: String
  allocationUser_contains_nocase: String
  allocationUser_ends_with: String
  allocationUser_ends_with_nocase: String
  allocationUser_gt: String
  allocationUser_gte: String
  allocationUser_in: [String!]
  allocationUser_lt: String
  allocationUser_lte: String
  allocationUser_not: String
  allocationUser_not_contains: String
  allocationUser_not_contains_nocase: String
  allocationUser_not_ends_with: String
  allocationUser_not_ends_with_nocase: String
  allocationUser_not_in: [String!]
  allocationUser_not_starts_with: String
  allocationUser_not_starts_with_nocase: String
  allocationUser_starts_with: String
  allocationUser_starts_with_nocase: String
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  chainId: BigInt
  chainId_gt: BigInt
  chainId_gte: BigInt
  chainId_in: [BigInt!]
  chainId_lt: BigInt
  chainId_lte: BigInt
  chainId_not: BigInt
  chainId_not_in: [BigInt!]
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  firstContact: Int
  firstContact_gt: Int
  firstContact_gte: Int
  firstContact_in: [Int!]
  firstContact_lt: Int
  firstContact_lte: Int
  firstContact_not: Int
  firstContact_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastContact: Int
  lastContact_gt: Int
  lastContact_gte: Int
  lastContact_in: [Int!]
  lastContact_lt: Int
  lastContact_lte: Int
  lastContact_not: Int
  lastContact_not_in: [Int!]
  nftAddress: String
  nftAddress_contains: String
  nftAddress_contains_nocase: String
  nftAddress_ends_with: String
  nftAddress_ends_with_nocase: String
  nftAddress_gt: String
  nftAddress_gte: String
  nftAddress_in: [String!]
  nftAddress_lt: String
  nftAddress_lte: String
  nftAddress_not: String
  nftAddress_not_contains: String
  nftAddress_not_contains_nocase: String
  nftAddress_not_ends_with: String
  nftAddress_not_ends_with_nocase: String
  nftAddress_not_in: [String!]
  nftAddress_not_starts_with: String
  nftAddress_not_starts_with_nocase: String
  nftAddress_starts_with: String
  nftAddress_starts_with_nocase: String
  tx: String
  tx_contains: String
  tx_contains_nocase: String
  tx_ends_with: String
  tx_ends_with_nocase: String
  tx_gt: String
  tx_gte: String
  tx_in: [String!]
  tx_lt: String
  tx_lte: String
  tx_not: String
  tx_not_contains: String
  tx_not_contains_nocase: String
  tx_not_ends_with: String
  tx_not_ends_with_nocase: String
  tx_not_in: [String!]
  tx_not_starts_with: String
  tx_not_starts_with_nocase: String
  tx_starts_with: String
  tx_starts_with_nocase: String
  updates_: VeAllocationUpdate_filter
}

enum VeAllocation_orderBy {
  allocated
  allocationId
  allocationUser
  block
  chainId
  eventIndex
  firstContact
  id
  lastContact
  nftAddress
  tx
  updates
}

type VeClaim {
  VeFeeDistributor: VeFeeDistributor!

  """amount of tokens claimed"""
  amount: BigDecimal!
  block: Int!

  """claim epoch"""
  claim_epoch: BigInt
  eventIndex: Int!

  """id = {tx}-{eventno}"""
  id: ID!

  """max_epoch"""
  max_epoch: BigInt
  timestamp: BigInt!
  tx: String!
  veOcean: VeOCEAN!
}

input VeClaim_filter {
  VeFeeDistributor: String
  VeFeeDistributor_: VeFeeDistributor_filter
  VeFeeDistributor_contains: String
  VeFeeDistributor_contains_nocase: String
  VeFeeDistributor_ends_with: String
  VeFeeDistributor_ends_with_nocase: String
  VeFeeDistributor_gt: String
  VeFeeDistributor_gte: String
  VeFeeDistributor_in: [String!]
  VeFeeDistributor_lt: String
  VeFeeDistributor_lte: String
  VeFeeDistributor_not: String
  VeFeeDistributor_not_contains: String
  VeFeeDistributor_not_contains_nocase: String
  VeFeeDistributor_not_ends_with: String
  VeFeeDistributor_not_ends_with_nocase: String
  VeFeeDistributor_not_in: [String!]
  VeFeeDistributor_not_starts_with: String
  VeFeeDistributor_not_starts_with_nocase: String
  VeFeeDistributor_starts_with: String
  VeFeeDistributor_starts_with_nocase: String

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  claim_epoch: BigInt
  claim_epoch_gt: BigInt
  claim_epoch_gte: BigInt
  claim_epoch_in: [BigInt!]
  claim_epoch_lt: BigInt
  claim_epoch_lte: BigInt
  claim_epoch_not: BigInt
  claim_epoch_not_in: [BigInt!]
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  max_epoch: BigInt
  max_epoch_gt: BigInt
  max_epoch_gte: BigInt
  max_epoch_in: [BigInt!]
  max_epoch_lt: BigInt
  max_epoch_lte: BigInt
  max_epoch_not: BigInt
  max_epoch_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  tx: String
  tx_contains: String
  tx_contains_nocase: String
  tx_ends_with: String
  tx_ends_with_nocase: String
  tx_gt: String
  tx_gte: String
  tx_in: [String!]
  tx_lt: String
  tx_lte: String
  tx_not: String
  tx_not_contains: String
  tx_not_contains_nocase: String
  tx_not_ends_with: String
  tx_not_ends_with_nocase: String
  tx_not_in: [String!]
  tx_not_starts_with: String
  tx_not_starts_with_nocase: String
  tx_starts_with: String
  tx_starts_with_nocase: String
  veOcean: String
  veOcean_: VeOCEAN_filter
  veOcean_contains: String
  veOcean_contains_nocase: String
  veOcean_ends_with: String
  veOcean_ends_with_nocase: String
  veOcean_gt: String
  veOcean_gte: String
  veOcean_in: [String!]
  veOcean_lt: String
  veOcean_lte: String
  veOcean_not: String
  veOcean_not_contains: String
  veOcean_not_contains_nocase: String
  veOcean_not_ends_with: String
  veOcean_not_ends_with_nocase: String
  veOcean_not_in: [String!]
  veOcean_not_starts_with: String
  veOcean_not_starts_with_nocase: String
  veOcean_starts_with: String
  veOcean_starts_with_nocase: String
}

enum VeClaim_orderBy {
  VeFeeDistributor
  amount
  block
  claim_epoch
  eventIndex
  id
  max_epoch
  timestamp
  tx
  veOcean
}

type VeDelegation {
  amount: BigDecimal!
  cancelTime: BigInt!
  delegator: VeOCEAN!
  expireTime: BigInt!

  """id = VeDelegation contract + tokenId"""
  id: ID!
  lockedAmount: BigDecimal!
  receiver: VeOCEAN!
  timeLeftUnlock: Int!
  tokenId: BigInt!
  updates(first: Int = 100, orderBy: VeDelegationUpdate_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: VeDelegationUpdate_filter): [VeDelegationUpdate!]
}

type VeDelegationUpdate {
  amount: BigDecimal!
  block: Int!
  cancelTime: BigInt!
  eventIndex: Int!
  expireTime: BigInt!

  """id = {tx}-{eventIndex}"""
  id: ID!
  sender: String!
  timestamp: Int!
  tx: String!

  """type: CREATE_BOOST = 0, EXTEND_BOOST = 1, BURN_BOOST = 2"""
  type: Int!
  veDelegation: VeDelegation!
}

input VeDelegationUpdate_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  cancelTime: BigInt
  cancelTime_gt: BigInt
  cancelTime_gte: BigInt
  cancelTime_in: [BigInt!]
  cancelTime_lt: BigInt
  cancelTime_lte: BigInt
  cancelTime_not: BigInt
  cancelTime_not_in: [BigInt!]
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  expireTime: BigInt
  expireTime_gt: BigInt
  expireTime_gte: BigInt
  expireTime_in: [BigInt!]
  expireTime_lt: BigInt
  expireTime_lte: BigInt
  expireTime_not: BigInt
  expireTime_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  sender: String
  sender_contains: String
  sender_contains_nocase: String
  sender_ends_with: String
  sender_ends_with_nocase: String
  sender_gt: String
  sender_gte: String
  sender_in: [String!]
  sender_lt: String
  sender_lte: String
  sender_not: String
  sender_not_contains: String
  sender_not_contains_nocase: String
  sender_not_ends_with: String
  sender_not_ends_with_nocase: String
  sender_not_in: [String!]
  sender_not_starts_with: String
  sender_not_starts_with_nocase: String
  sender_starts_with: String
  sender_starts_with_nocase: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  tx: String
  tx_contains: String
  tx_contains_nocase: String
  tx_ends_with: String
  tx_ends_with_nocase: String
  tx_gt: String
  tx_gte: String
  tx_in: [String!]
  tx_lt: String
  tx_lte: String
  tx_not: String
  tx_not_contains: String
  tx_not_contains_nocase: String
  tx_not_ends_with: String
  tx_not_ends_with_nocase: String
  tx_not_in: [String!]
  tx_not_starts_with: String
  tx_not_starts_with_nocase: String
  tx_starts_with: String
  tx_starts_with_nocase: String
  type: Int
  type_gt: Int
  type_gte: Int
  type_in: [Int!]
  type_lt: Int
  type_lte: Int
  type_not: Int
  type_not_in: [Int!]
  veDelegation: String
  veDelegation_: VeDelegation_filter
  veDelegation_contains: String
  veDelegation_contains_nocase: String
  veDelegation_ends_with: String
  veDelegation_ends_with_nocase: String
  veDelegation_gt: String
  veDelegation_gte: String
  veDelegation_in: [String!]
  veDelegation_lt: String
  veDelegation_lte: String
  veDelegation_not: String
  veDelegation_not_contains: String
  veDelegation_not_contains_nocase: String
  veDelegation_not_ends_with: String
  veDelegation_not_ends_with_nocase: String
  veDelegation_not_in: [String!]
  veDelegation_not_starts_with: String
  veDelegation_not_starts_with_nocase: String
  veDelegation_starts_with: String
  veDelegation_starts_with_nocase: String
}

enum VeDelegationUpdate_orderBy {
  amount
  block
  cancelTime
  eventIndex
  expireTime
  id
  sender
  timestamp
  tx
  type
  veDelegation
}

input VeDelegation_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  cancelTime: BigInt
  cancelTime_gt: BigInt
  cancelTime_gte: BigInt
  cancelTime_in: [BigInt!]
  cancelTime_lt: BigInt
  cancelTime_lte: BigInt
  cancelTime_not: BigInt
  cancelTime_not_in: [BigInt!]
  delegator: String
  delegator_: VeOCEAN_filter
  delegator_contains: String
  delegator_contains_nocase: String
  delegator_ends_with: String
  delegator_ends_with_nocase: String
  delegator_gt: String
  delegator_gte: String
  delegator_in: [String!]
  delegator_lt: String
  delegator_lte: String
  delegator_not: String
  delegator_not_contains: String
  delegator_not_contains_nocase: String
  delegator_not_ends_with: String
  delegator_not_ends_with_nocase: String
  delegator_not_in: [String!]
  delegator_not_starts_with: String
  delegator_not_starts_with_nocase: String
  delegator_starts_with: String
  delegator_starts_with_nocase: String
  expireTime: BigInt
  expireTime_gt: BigInt
  expireTime_gte: BigInt
  expireTime_in: [BigInt!]
  expireTime_lt: BigInt
  expireTime_lte: BigInt
  expireTime_not: BigInt
  expireTime_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lockedAmount: BigDecimal
  lockedAmount_gt: BigDecimal
  lockedAmount_gte: BigDecimal
  lockedAmount_in: [BigDecimal!]
  lockedAmount_lt: BigDecimal
  lockedAmount_lte: BigDecimal
  lockedAmount_not: BigDecimal
  lockedAmount_not_in: [BigDecimal!]
  receiver: String
  receiver_: VeOCEAN_filter
  receiver_contains: String
  receiver_contains_nocase: String
  receiver_ends_with: String
  receiver_ends_with_nocase: String
  receiver_gt: String
  receiver_gte: String
  receiver_in: [String!]
  receiver_lt: String
  receiver_lte: String
  receiver_not: String
  receiver_not_contains: String
  receiver_not_contains_nocase: String
  receiver_not_ends_with: String
  receiver_not_ends_with_nocase: String
  receiver_not_in: [String!]
  receiver_not_starts_with: String
  receiver_not_starts_with_nocase: String
  receiver_starts_with: String
  receiver_starts_with_nocase: String
  timeLeftUnlock: Int
  timeLeftUnlock_gt: Int
  timeLeftUnlock_gte: Int
  timeLeftUnlock_in: [Int!]
  timeLeftUnlock_lt: Int
  timeLeftUnlock_lte: Int
  timeLeftUnlock_not: Int
  timeLeftUnlock_not_in: [Int!]
  tokenId: BigInt
  tokenId_gt: BigInt
  tokenId_gte: BigInt
  tokenId_in: [BigInt!]
  tokenId_lt: BigInt
  tokenId_lte: BigInt
  tokenId_not: BigInt
  tokenId_not_in: [BigInt!]
  updates_: VeDelegationUpdate_filter
}

enum VeDelegation_orderBy {
  amount
  cancelTime
  delegator
  expireTime
  id
  lockedAmount
  receiver
  timeLeftUnlock
  tokenId
  updates
}

type VeDeposit {
  block: Int!
  eventIndex: Int!

  """id = {user address}-{tx}-{eventIndex}"""
  id: ID!

  """veOcean holder"""
  provider: String!

  """who initiated the tx"""
  sender: String!
  timestamp: BigInt!
  totalOceanLocked: BigDecimal!
  tx: String!

  """
  deposit type: DEPOSIT_FOR = 0, CREATE_LOCK_TYPE = 1,INCREASE_LOCK_AMOUNT = 2,INCREASE_UNLOCK_TIME = 3, WITHDRAW = 4
  """
  type: BigInt!

  """unlock timestamp"""
  unlockTime: BigInt!

  """amount of tokens locked"""
  value: BigDecimal!
  veOcean: VeOCEAN!
}

input VeDeposit_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  provider: String
  provider_contains: String
  provider_contains_nocase: String
  provider_ends_with: String
  provider_ends_with_nocase: String
  provider_gt: String
  provider_gte: String
  provider_in: [String!]
  provider_lt: String
  provider_lte: String
  provider_not: String
  provider_not_contains: String
  provider_not_contains_nocase: String
  provider_not_ends_with: String
  provider_not_ends_with_nocase: String
  provider_not_in: [String!]
  provider_not_starts_with: String
  provider_not_starts_with_nocase: String
  provider_starts_with: String
  provider_starts_with_nocase: String
  sender: String
  sender_contains: String
  sender_contains_nocase: String
  sender_ends_with: String
  sender_ends_with_nocase: String
  sender_gt: String
  sender_gte: String
  sender_in: [String!]
  sender_lt: String
  sender_lte: String
  sender_not: String
  sender_not_contains: String
  sender_not_contains_nocase: String
  sender_not_ends_with: String
  sender_not_ends_with_nocase: String
  sender_not_in: [String!]
  sender_not_starts_with: String
  sender_not_starts_with_nocase: String
  sender_starts_with: String
  sender_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  totalOceanLocked: BigDecimal
  totalOceanLocked_gt: BigDecimal
  totalOceanLocked_gte: BigDecimal
  totalOceanLocked_in: [BigDecimal!]
  totalOceanLocked_lt: BigDecimal
  totalOceanLocked_lte: BigDecimal
  totalOceanLocked_not: BigDecimal
  totalOceanLocked_not_in: [BigDecimal!]
  tx: String
  tx_contains: String
  tx_contains_nocase: String
  tx_ends_with: String
  tx_ends_with_nocase: String
  tx_gt: String
  tx_gte: String
  tx_in: [String!]
  tx_lt: String
  tx_lte: String
  tx_not: String
  tx_not_contains: String
  tx_not_contains_nocase: String
  tx_not_ends_with: String
  tx_not_ends_with_nocase: String
  tx_not_in: [String!]
  tx_not_starts_with: String
  tx_not_starts_with_nocase: String
  tx_starts_with: String
  tx_starts_with_nocase: String
  type: BigInt
  type_gt: BigInt
  type_gte: BigInt
  type_in: [BigInt!]
  type_lt: BigInt
  type_lte: BigInt
  type_not: BigInt
  type_not_in: [BigInt!]
  unlockTime: BigInt
  unlockTime_gt: BigInt
  unlockTime_gte: BigInt
  unlockTime_in: [BigInt!]
  unlockTime_lt: BigInt
  unlockTime_lte: BigInt
  unlockTime_not: BigInt
  unlockTime_not_in: [BigInt!]
  value: BigDecimal
  value_gt: BigDecimal
  value_gte: BigDecimal
  value_in: [BigDecimal!]
  value_lt: BigDecimal
  value_lte: BigDecimal
  value_not: BigDecimal
  value_not_in: [BigDecimal!]
  veOcean: String
  veOcean_: VeOCEAN_filter
  veOcean_contains: String
  veOcean_contains_nocase: String
  veOcean_ends_with: String
  veOcean_ends_with_nocase: String
  veOcean_gt: String
  veOcean_gte: String
  veOcean_in: [String!]
  veOcean_lt: String
  veOcean_lte: String
  veOcean_not: String
  veOcean_not_contains: String
  veOcean_not_contains_nocase: String
  veOcean_not_ends_with: String
  veOcean_not_ends_with_nocase: String
  veOcean_not_in: [String!]
  veOcean_not_starts_with: String
  veOcean_not_starts_with_nocase: String
  veOcean_starts_with: String
  veOcean_starts_with_nocase: String
}

enum VeDeposit_orderBy {
  block
  eventIndex
  id
  provider
  sender
  timestamp
  totalOceanLocked
  tx
  type
  unlockTime
  value
  veOcean
}

type VeFeeDistributor {
  checkpoints(first: Int = 100, orderBy: VeFeeDistributorCheckPoint_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: VeFeeDistributorCheckPoint_filter): [VeFeeDistributorCheckPoint!]
  claims(first: Int = 100, orderBy: VeClaim_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: VeClaim_filter): [VeClaim!]

  """id = contract address"""
  id: ID!

  """token used by FeeDistributor"""
  token: Token!
}

type VeFeeDistributorCheckPoint {
  VeFeeDistributor: VeFeeDistributor!
  block: Int!
  eventIndex: Int!

  """id = {tx}-{eventno}"""
  id: ID!

  """who initiated the tx"""
  sender: String!
  timestamp: BigInt!

  """amount of tokens for rewards"""
  tokens: BigDecimal!
  tx: String!
}

input VeFeeDistributorCheckPoint_filter {
  VeFeeDistributor: String
  VeFeeDistributor_: VeFeeDistributor_filter
  VeFeeDistributor_contains: String
  VeFeeDistributor_contains_nocase: String
  VeFeeDistributor_ends_with: String
  VeFeeDistributor_ends_with_nocase: String
  VeFeeDistributor_gt: String
  VeFeeDistributor_gte: String
  VeFeeDistributor_in: [String!]
  VeFeeDistributor_lt: String
  VeFeeDistributor_lte: String
  VeFeeDistributor_not: String
  VeFeeDistributor_not_contains: String
  VeFeeDistributor_not_contains_nocase: String
  VeFeeDistributor_not_ends_with: String
  VeFeeDistributor_not_ends_with_nocase: String
  VeFeeDistributor_not_in: [String!]
  VeFeeDistributor_not_starts_with: String
  VeFeeDistributor_not_starts_with_nocase: String
  VeFeeDistributor_starts_with: String
  VeFeeDistributor_starts_with_nocase: String

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  eventIndex: Int
  eventIndex_gt: Int
  eventIndex_gte: Int
  eventIndex_in: [Int!]
  eventIndex_lt: Int
  eventIndex_lte: Int
  eventIndex_not: Int
  eventIndex_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  sender: String
  sender_contains: String
  sender_contains_nocase: String
  sender_ends_with: String
  sender_ends_with_nocase: String
  sender_gt: String
  sender_gte: String
  sender_in: [String!]
  sender_lt: String
  sender_lte: String
  sender_not: String
  sender_not_contains: String
  sender_not_contains_nocase: String
  sender_not_ends_with: String
  sender_not_ends_with_nocase: String
  sender_not_in: [String!]
  sender_not_starts_with: String
  sender_not_starts_with_nocase: String
  sender_starts_with: String
  sender_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  tokens: BigDecimal
  tokens_gt: BigDecimal
  tokens_gte: BigDecimal
  tokens_in: [BigDecimal!]
  tokens_lt: BigDecimal
  tokens_lte: BigDecimal
  tokens_not: BigDecimal
  tokens_not_in: [BigDecimal!]
  tx: String
  tx_contains: String
  tx_contains_nocase: String
  tx_ends_with: String
  tx_ends_with_nocase: String
  tx_gt: String
  tx_gte: String
  tx_in: [String!]
  tx_lt: String
  tx_lte: String
  tx_not: String
  tx_not_contains: String
  tx_not_contains_nocase: String
  tx_not_ends_with: String
  tx_not_ends_with_nocase: String
  tx_not_in: [String!]
  tx_not_starts_with: String
  tx_not_starts_with_nocase: String
  tx_starts_with: String
  tx_starts_with_nocase: String
}

enum VeFeeDistributorCheckPoint_orderBy {
  VeFeeDistributor
  block
  eventIndex
  id
  sender
  timestamp
  tokens
  tx
}

input VeFeeDistributor_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  checkpoints_: VeFeeDistributorCheckPoint_filter
  claims_: VeClaim_filter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
}

enum VeFeeDistributor_orderBy {
  checkpoints
  claims
  id
  token
}

type VeOCEAN {
  allocation: VeAllocateUser
  block: Int!
  claims(first: Int = 100, orderBy: VeClaim_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: VeClaim_filter): [VeClaim!]
  delegates(first: Int = 100, orderBy: VeDelegation_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: VeDelegation_filter): [VeDelegation!]
  delegation(first: Int = 100, orderBy: VeDelegation_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: VeDelegation_filter): [VeDelegation!]
  deposits(first: Int = 100, orderBy: VeDeposit_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: VeDeposit_filter): [VeDeposit!]

  """id = {user address}"""
  id: ID!

  """total amount of locked tokens"""
  lockedAmount: BigDecimal!

  """unlock timestamp"""
  unlockTime: BigInt!
}

input VeOCEAN_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  allocation_: VeAllocateUser_filter
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  claims_: VeClaim_filter
  delegates_: VeDelegation_filter
  delegation_: VeDelegation_filter
  deposits_: VeDeposit_filter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lockedAmount: BigDecimal
  lockedAmount_gt: BigDecimal
  lockedAmount_gte: BigDecimal
  lockedAmount_in: [BigDecimal!]
  lockedAmount_lt: BigDecimal
  lockedAmount_lte: BigDecimal
  lockedAmount_not: BigDecimal
  lockedAmount_not_in: [BigDecimal!]
  unlockTime: BigInt
  unlockTime_gt: BigInt
  unlockTime_gte: BigInt
  unlockTime_in: [BigInt!]
  unlockTime_lt: BigInt
  unlockTime_lte: BigInt
  unlockTime_not: BigInt
  unlockTime_not_in: [BigInt!]
}

enum VeOCEAN_orderBy {
  allocation
  block
  claims
  delegates
  delegation
  deposits
  id
  lockedAmount
  unlockTime
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes

  """The block number"""
  number: Int!

  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  "Information about a specific subgraph block. The hash of the block\nwill be null if the _meta field has a block constraint that asks for\na block number. It will be filled if the _meta field has no block constraint\nand therefore asks for the latest  block\n"
  block: _Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

enum veAllocationUpdateType {
  REMOVED
  SET
}